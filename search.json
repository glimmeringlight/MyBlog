[{"title":"强化学习：基本概念和优化目标","path":"/posts/28/","content":"强化学习是指导智能体如何根据环境反馈而选择最佳决策的学习方式，本文主要介绍强化学习的基本概念和优化目标。 强化学习基本概念 什么是强化学习？ Reinforcement learning is learning what to do—how to map situations to actions——so as to maximize a numerical reward signal. ----- Richard S. Sutton and Andrew G. Barto 《Reinforcement Learning: An Introduction II》 强化学习(Reinforcement learning，RL)讨论的问题是一个智能体(agent)怎么在一个复杂不确定的环境(environment)里面去极大化它能获得的奖励。通过感知所处环境的状态(state)对动作(action)的反应(reward)，来指导更好的动作，从而获得最大的收益(return)，这被称为在交互中学习，这样的学习方法就被称作强化学习。 强化学习的基本流程和概念 在强化学习中，存在一些基本的概念。理解清楚这些概念对我们后续的学习具有重要的铺垫意义，本部分总结阅读本文需要了解的基础概念，并给出符号表示。 一般来说，强化学习的流程如下图所示： 强化学习的基本流程 Agent基于对环境的观察（又称state）选择下一步行动action，同时，Agent产生的行动action又会反作用于环境（Environment），从而推进到下一个State。上述过程循环往复，形成Agent和Environment的基本交互流程。 为了形式化地描述上述过程，对其中的一些概念进行定义。 动作空间：是Agent每个状态下可选择的动作的集合，一般使用如集合 {a1,a2,…,an}\\{a_1, a_2, \\dots, a_n\\}{a1​,a2​,…,an​} 的形式表示； 策略函数(Policy)：表示在给定状态下，Agent采取不同行动的概率值，是一个概率分布。通常以 P(ai∣st)P(a_i \\mid s_t)P(ai​∣st​) 的形式表示； 轨迹(Trajectory)：Agent所处的状态以及采取的行动的序列，一般为 {s0,a0,s1,a1,…,sm,am}\\{s_0, a_0, s_1, a_1, \\dots, s_m, a_m\\}{s0​,a0​,s1​,a1​,…,sm​,am​}； 奖励(Reward)：表示Agent每一次行动后环境给出的评价； 回报(Return)：表示从当前时刻起，直到结束时间所获得的总的奖励之和。依据算法不同，可能会引入衰减因子 γ\\gammaγ 。 强化学习的优化目标 目标函数 强化学习的优化目标，就是要找出一条轨迹，使得其能够带来最大的总回报。也就是说，我们需要选出一条轨迹 τ\\tauτ ，使得： E(R(τ))τ∼Pθ(τ)=∑τR(τ)Pθ(τ)E(R(\\tau))_{\\tau \\sim P_\\theta (\\tau)}=\\sum _{\\tau}R(\\tau)P_\\theta (\\tau) E(R(τ))τ∼Pθ​(τ)​=τ∑​R(τ)Pθ​(τ) 最大化。其中， θ\\thetaθ 是模型参数。我们训练模型，就是找到一组更好的参数 θ\\thetaθ。 梯度上升法 要最大化上述目标函数，通常使用的方法是梯度上升法，也即求取上述目标函数的梯度值，而后依据学习率(Learning Rate)，进行梯度上升。上述目标函数的梯度可由如下运算获得： ∇E(R(τ))τ∼Pθ(τ)=∑τR(τ)∇Pθ(τ)=∑τPθ(τ)R(τ)∇Pθ(τ)Pθ(τ)≈1N∑i=1NR(τi)∇Pθ(τi)Pθ(τi)=1N∑i=1NR(τi)∇log⁡Pθ(τi).\\begin{aligned} abla E(R(\\tau))_{\\tau \\sim P_\\theta (\\tau)}=\\sum _{\\tau}R(\\tau) abla P_\\theta (\\tau)\\\\ =\\sum _{\\tau}P_\\theta (\\tau)R(\\tau)\\dfrac{ abla P_\\theta (\\tau)}{P_\\theta (\\tau)}\\\\ \\approx \\dfrac{1}{N}\\sum _{i=1}^N R(\\tau^i)\\dfrac{ abla P_\\theta (\\tau ^i)}{P_\\theta (\\tau ^i)}\\\\ = \\dfrac{1}{N}\\sum _{i=1}^N R(\\tau^i) abla \\log P_\\theta (\\tau ^i). \\end{aligned} ∇E(R(τ))τ∼Pθ​(τ)​​=τ∑​R(τ)∇Pθ​(τ)=τ∑​Pθ​(τ)R(τ)Pθ​(τ)∇Pθ​(τ)​≈N1​i=1∑N​R(τi)Pθ​(τi)∇Pθ​(τi)​=N1​i=1∑N​R(τi)∇logPθ​(τi).​ 上述的不等号由大数定律而得，即使用多次随机采样的结果来逼近期望值。τi\\tau ^iτi 的上标 iii 表示采样次数，对于不同的两次采样，均独立且服从于 Pθ(τ)P _\\theta (\\tau)Pθ​(τ) 的分布。 对于轨迹 τi\\tau ^iτi 的概率分布 P(τi)P(\\tau ^i)P(τi)，可以使用条件概率将其拆分开，如下表示： Pθ(τi)=∏t=1TiPθ(ati∣sti).P_\\theta (\\tau ^i) = \\prod _{t=1}^{T_i} P _\\theta (a^i_t \\mid s^i_t). Pθ​(τi)=t=1∏Ti​​Pθ​(ati​∣sti​). 因此，上述梯度还可以进一步表示为： ∇E(R(τ))τ∼Pθ(τ)=1N∑i=1NR(τi)∇log⁡Pθ(τi)=1N∑i=1NR(τi)∇log⁡∏t=1TiPθ(ati∣sti)=1N∑t=1Ti∑i=1NR(τi)∇log⁡Pθ(ati∣sti).\\begin{aligned} abla E(R(\\tau))_{\\tau \\sim P_\\theta (\\tau)}=\\dfrac{1}{N}\\sum _{i=1}^N R(\\tau^i) abla \\log P_\\theta (\\tau ^i)\\\\ =\\dfrac{1}{N}\\sum _{i=1}^N R(\\tau^i) abla \\log \\prod _{t=1}^{T_i} P _\\theta (a^i_t \\mid s^i_t)\\\\ =\\dfrac{1}{N}\\sum _{t=1}^{T_i}\\sum _{i=1}^N R(\\tau^i) abla \\log P _\\theta (a^i_t \\mid s^i_t). \\end{aligned} ∇E(R(τ))τ∼Pθ​(τ)​​=N1​i=1∑N​R(τi)∇logPθ​(τi)=N1​i=1∑N​R(τi)∇logt=1∏Ti​​Pθ​(ati​∣sti​)=N1​t=1∑Ti​​i=1∑N​R(τi)∇logPθ​(ati​∣sti​).​ 上述优化目标对应的 损失函数(Loss Function) 为： loss=−1N∑t=1Ti∑i=1NR(τi)log⁡Pθ(ati∣sti).\\text{loss} =-\\dfrac{1}{N}\\sum _{t=1}^{T_i}\\sum _{i=1}^N R(\\tau^i) \\log P _\\theta (a^i_t \\mid s^i_t). loss=−N1​t=1∑Ti​​i=1∑N​R(τi)logPθ​(ati​∣sti​). 在一次训练中，通过与环境进行多次完整的互动，得到每次轨迹的总回报值 R(τi)R(\\tau ^i)R(τi) ，并记录在每一个不同状态下的行动概率分布 Pθ(ati∣sti)P_\\theta (a^i_t \\mid s^i_t)Pθ​(ati​∣sti​) ，进行反向传播，降低loss。 上述loss函数存在的问题 上述loss函数尽管已经能体现出不错的训练效果，但其还存在一些细节上的问题。比如： 对于某条给定的轨迹 τi\\tau ^iτi ，其中每一步行动的价值都等同于整个轨迹的回报 R(τi)R(\\tau ^i)R(τi) 吗？ 若某条轨迹 τi\\tau ^iτi 的回报小于零，那么这条轨迹中所有的行动选择都是错误的吗？ 先看第一个问题。显然，根据因果关系，在某一时刻的行动抉择，理应只能够影响后续的回报，而对前面的回报无法产生影响。因此，回报 R(τi)R(\\tau ^i)R(τi) 应该使用 RtiR_t^iRti​ 来替代： Rti=∑t′=tTiγt′−trt′i.R_t^i = \\sum_{t^\\prime = t}^{T_i} \\gamma ^{t^\\prime - t}r_{t^\\prime} ^i. Rti​=t′=t∑Ti​​γt′−trt′i​. 上述中的衰减因子 γ\\gammaγ 是一个超参数，它表示如果奖励一致，那么更早地获取奖励比更晚要好，这也符合一般直觉。 第二个问题中，我们假定这样一个场景。在某个状态下，动作空间为 {A,B,C}\\{A,B,C\\}{A,B,C}，且三者对应的回报为 2,5,42,5,42,5,4。显然，三者都大于零，但是三种动作都是值得奖励的吗？反过来，如果三者对应的回报为 −4,−1,−7-4,-1,-7−4,−1,−7，那么三者都是值得惩罚的吗？事实上并不是。我们需要引导Agent做出当下的最优解，而不仅仅局限于回报的绝对大小。因此，在状态 stis_t^isti​ 下，我们引入Baseline B(sti)B(s_t^i)B(sti​) ，用来衡量该状态下各种不同行动的 平均回报 ，并以此作为基准鼓励Agent采取能够获得高于平均回报的动作。 结合上述两个分析，最优化目标的梯度被更新为： 1N∑t=1Ti∑i=1N(Rti−B(sti))∇log⁡Pθ(ati∣sti).\\dfrac{1}{N}\\sum _{t=1}^{T_i}\\sum _{i=1}^N (R_t^i-B(s_t^i)) abla \\log P _\\theta (a^i_t \\mid s^i_t). N1​t=1∑Ti​​i=1∑N​(Rti​−B(sti​))∇logPθ​(ati​∣sti​). 行动价值、状态价值和优势 引出了上述公式后，我们不妨再形式化一些概念，好让上述推导变得更加清晰明显。 行动价值函数(Action Value Function)，顾名思义，表示在某一状态下采取给定行动所能带来的回报。该函数用以取代上面的 RtiR^i_tRti​ ，原因是因为该值为随机采样得到的结果，具有较大的不确定性。行动价值函数 Qθ(st,a)Q_\\theta (s_t,a)Qθ​(st​,a) 则能较为稳定地反应状态 sts_tst​ 下选择行动 aaa 所得的回报。 状态价值函数(State Value Function), 用于评估状态的好坏，也可以理解成该状态下选择不同行动的平均回报，用 Vθ(st)V_\\theta (s_t)Vθ​(st​) 表示。 优势函数(Advantage Function)，用于描述在当前状态下采取某一行动的优势的度量。其与上述函数存在关系： Aθ(st,a)=Qθ(st,a)−Vθ(st).A_\\theta (s_t, a)=Q_\\theta (s_t, a)-V_\\theta (s_t). Aθ​(st​,a)=Qθ​(st​,a)−Vθ​(st​). 经过更严格的定义，优化目标可以继续被改写为： 1N∑t=1Ti∑i=1NAθ(sti,ai)∇log⁡Pθ(ati∣sti).\\dfrac{1}{N}\\sum _{t=1}^{T_i}\\sum _{i=1}^N A_\\theta (s_t^i, a^i) abla \\log P _\\theta (a^i_t \\mid s^i_t). N1​t=1∑Ti​​i=1∑N​Aθ​(sti​,ai)∇logPθ​(ati​∣sti​). 行动价值、状态价值和优势的计算方式 关于上述三个函数，一个比较显然的关系式为： Qθ(st,a)=rt+γVθ(st+1).Q_\\theta (s_t, a) = r_t + \\gamma V_\\theta (s_{t+1}). Qθ​(st​,a)=rt​+γVθ​(st+1​). 这表示：在当前状态采取某一行动所获得的回报应该等于当前瞬间环境给出的奖励，以及转移到的新状态所蕴含的回报的折扣之和。 严格来说，上式应通过如下方法导出： Qθ(st,a)=E(rt+γrt+1+⋯∣st,at)=E(rt∣st,at)+γE(rt+1+γrt+2+⋯∣st,at)=E(rt∣st,at)+γ∑st+1Pθ(st+1)Vθ(st+1).\\begin{aligned} Q_\\theta (s_t, a)=E(r_t+\\gamma r_{t+1} + \\dots \\mid s_t, a_t)\\\\ =E(r_t\\mid s_t, a_t)+\\gamma E(r_{t+1} + \\gamma r_{t+2} + \\dots\\mid s_t,a_t)\\\\ =E(r_t\\mid s_t, a_t) + \\gamma \\sum_{s_{t+1}}P_\\theta(s_{t+1})V_\\theta(s_{t+1}). \\end{aligned} Qθ​(st​,a)​=E(rt​+γrt+1​+⋯∣st​,at​)=E(rt​∣st​,at​)+γE(rt+1​+γrt+2​+⋯∣st​,at​)=E(rt​∣st​,at​)+γst+1​∑​Pθ​(st+1​)Vθ​(st+1​).​ 于是，一步采样（表示为 AAA 的上标）得到的优势函数可以展开为如下形式： Aθ1(st,a)=rt+γVθ(st+1)−Vθ(st).A_\\theta^1 (s_t, a) = r_t + \\gamma V_\\theta (s_{t+1}) - V_\\theta (s_t). Aθ1​(st​,a)=rt​+γVθ​(st+1​)−Vθ​(st​). 另一较不显然的公式为： Vθ(st)≈rt+γVθ(st+1).V_\\theta(s_t)\\approx r_t+\\gamma V_\\theta(s_{t+1}). Vθ​(st​)≈rt​+γVθ​(st+1​). 严格来说，上式应通过如下方法导出： Vθ(st)=E(rt+γrt+1+⋯∣st)=E(rt∣st)+γE(rt+1+γrt+2∣st)=E(rt∣st)+γ∑st+1Pθ(st+1)Vθ(st+1)≈rt+γVθ(st+1).\\begin{aligned} V_\\theta(s_t)=E(r_t+\\gamma r_{t+1}+\\dots \\mid s_t)\\\\ =E(r_t\\mid s_t) +\\gamma E(r_{t+1} + \\gamma r_{t+2}\\mid s_t)\\\\ =E(r_t\\mid s_t) + \\gamma \\sum_{s_{t+1}}P_\\theta(s_{t+1})V_\\theta(s_{t+1})\\\\ \\approx r_t + \\gamma V_\\theta(s_{t+1}). \\end{aligned} Vθ​(st​)​=E(rt​+γrt+1​+⋯∣st​)=E(rt​∣st​)+γE(rt+1​+γrt+2​∣st​)=E(rt​∣st​)+γst+1​∑​Pθ​(st+1​)Vθ​(st+1​)≈rt​+γVθ​(st+1​).​ 因此，可以通过展开 Vθ(st+i)V_\\theta (s_{t+i})Vθ​(st+i​) 来获取多步采样的优势函数 Aθ(st,a)A_\\theta (s_t,a)Aθ​(st​,a).例如两步采样： Aθ2=rt+γrt+1+γ2Vθ(st+2)−Vθ(st),A_\\theta ^2=r_t+\\gamma r_{t+1} + \\gamma ^2V_\\theta(s_{t+2})-V_\\theta (s_t), Aθ2​=rt​+γrt+1​+γ2Vθ​(st+2​)−Vθ​(st​), 三步采样： Aθ3=rt+γrt+1+γ2rt+2+γ3Vθ(st+3)−Vθ(st),A_\\theta^3=r_t+\\gamma r_{t+1} + \\gamma ^2r_{t+2} + \\gamma ^3 V_\\theta(s_{t+3}) - V_\\theta(s_t), Aθ3​=rt​+γrt+1​+γ2rt+2​+γ3Vθ​(st+3​)−Vθ​(st​), 等等。 为了表示方便，使用新的记号 δtV\\delta _t^VδtV​ 表示在状态 VVV 下，ttt 时刻做出选择后产生的优势： δtV=rt+γVθ(st+1)−Vθ(st).\\delta _t^V = r_t + \\gamma V_\\theta(s_{t+1}) - V_\\theta (s_t). δtV​=rt​+γVθ​(st+1​)−Vθ​(st​). 那么 kkk 步优势可以简化成： Aθk=∑i=0k−1γiδt+iV.A_\\theta ^k=\\sum_{i=0}^{k-1}\\gamma ^i \\delta^V_{t+i}. Aθk​=i=0∑k−1​γiδt+iV​. 广义优势估计 广义优势估计(Generalized Advantage Estimation, GAE) 是一种综合考虑了多步优势的一种优势估计方法，并使用一定的权重来平衡之。 AθGAE=(1−λ)(Aθ1+λAθ2+λ2Aθ3+… )=∑b=0∞(γλ)bδt+bV.\\begin{aligned} A_\\theta ^{GAE} = (1-\\lambda)(A_\\theta ^1 + \\lambda A_\\theta ^2 + \\lambda ^2A_\\theta ^3 + \\dots)\\\\ =\\sum_{b=0}^\\infty (\\gamma \\lambda)^b\\delta_{t+b}^V. \\end{aligned} AθGAE​​=(1−λ)(Aθ1​+λAθ2​+λ2Aθ3​+…)=b=0∑∞​(γλ)bδt+bV​.​ 总结 通过上述大量的数学推导，我们得到的了最后的优化目标： 1N∑t=1Ti∑i=1NAθGAE∇log⁡Pθ(ati∣sti).\\dfrac{1}{N}\\sum _{t=1}^{T_i}\\sum _{i=1}^N A_\\theta ^{GAE} abla \\log P _\\theta (a^i_t \\mid s^i_t). N1​t=1∑Ti​​i=1∑N​AθGAE​∇logPθ​(ati​∣sti​). 其中，广义优势估计的计算方法为： AθGAE=∑b=0∞(γλ)bδt+bV,A_\\theta ^{GAE} = \\sum_{b=0}^\\infty (\\gamma \\lambda)^b\\delta_{t+b}^V, AθGAE​=b=0∑∞​(γλ)bδt+bV​, 其中，δtV=rt+γVθ(st+1)−Vθ(st)\\delta _t^V = r_t + \\gamma V_\\theta(s_{t+1}) - V_\\theta (s_t)δtV​=rt​+γVθ​(st+1​)−Vθ​(st​). 在训练过程中，需要另一个模型来拟合状态价值函数 Vθ(st)V_\\theta(s_t)Vθ​(st​)，其拟合目标为： Vθ(st)=∑t′=tTiγt′−trt′i.V_\\theta(s_t) = \\sum_{t^\\prime = t}^{T_i} \\gamma ^{t^\\prime - t}r_{t^\\prime} ^i. Vθ​(st​)=t′=t∑Ti​​γt′−trt′i​. 因此，完成上述过程的训练一共需要三个模型：策略模型(Policy Model)、奖励模型(Reward Model)和回报模型(Reward Model)。","tags":["强化学习"],"categories":["AI","强化学习"]},{"title":"C++条件变量(Conditional Variable)","path":"/posts/27/","content":"概述 C++中的条件变量(Conditional Variable)是一种特殊的变量，常用于线程之间的同步。在涉及到诸如：线程因某种原因需要被阻塞，待其满足某些条件时，另一个线程会将该线程唤醒这类应用场景下，条件变量提供了一种优雅的解决方式。 通常，条件变量与锁一同使用，防止数据竞争。 使用流程 如图所示为条件变量的一般使用情景。 条件变量应用情景 在此场景下，待唤醒线程一般处于等待状态，等待满足某些特定条件后被其它线程唤醒；唤醒线程则处理其它功能，并在条件满足的情况下唤醒待唤醒线程。conditional_variable完成了上述通知的功能；shared_data则是不同线程之间的共享缓存区，用于数据共享；mutex则是锁，用于保护conditional_variable和shared_data之间的数据同步。 代码接口 条件变量位于标准库conditional_variable中，首先需要包含该头文件。头文件中提供了一系列接口，主要分为两个功能：等待和通知。 函数名称 函数功能 wait 阻塞该线程并等待唤醒 wait_for 阻塞该线程并等待，或者超时 wait_until 阻塞该线程并等待，或者到达某一时间点 notify_one 唤醒一个线程 notify_all 唤醒所有线程 等待函数wait() 函数wait的其中一个函数签名如： wait(unique_lockmutex __lock); 其中，__lock是需要获取的锁。在调用wait()前，当前线程必须已经竞争获得锁，而后进入wait()。wait()函数中，会主动释放当前线程获得的锁，并进入阻塞状态；当其它线程获得锁并调用notify_one()或notify_any()进行线程唤醒时，当前线程则会退出阻塞状态，并重新试图获取锁。 丢失唤醒和虚假唤醒 上述的wait()函数在实际使用中，可能会遇到丢失唤醒或者虚假唤醒的情况。所谓丢失唤醒，则是在其它线程发出notify时，该线程尚且没有进入等待的阻塞状态，当该线程进入阻塞状态时，已经错过了通知唤醒，进而导致死锁；所谓虚假唤醒，则是由于底层硬件和软件在处理大规模操作时产生的短暂性系统混乱，导致在未收到唤醒通知的情况下提前被唤醒。虚假唤醒的成因是多种多样的，但究其本质都离不开短时间内的内核调度或信号中断等现象，读者可以自行了解。 为了防止上述情况的产生，wait()函数还有一个重载版本，其函数签名如下： templatetypename _Predicatevoid wait(unique_lockmutex __lock, _Predicate __p); 其中，__p是一个可调用对象，可以是仿函数，也可以是lambda表达式。其相当于一个阻塞条件，当不满足该条件时，当前线程才会被阻塞；反之，则会退出阻塞状态。上述wait()相当于如下的代码段： while(!__p()) wait(__lock); 因此，如果存在丢失唤醒的情况，则while的判断首先不成立，线程也不会进入阻塞状态；如果存在虚假唤醒的情况，则满足while的循环条件，也就会再次进入阻塞状态。 唤醒函数 conditional_variable中提供了两种唤醒函数，分别为notify_one()和notify_all()。两者的唯一区别在于前者是唤醒被当前条件变量阻塞的线程中的一个线程，而后者则是唤醒所有线程。若有多个线程被同一个条件变量阻塞，则notify_one()的唤醒是随机的，也即无法选择具体的唤醒线程。notify内部相当于获取了锁，而后唤醒对应线程，再释放锁。 条件变量的例子 条件变量通常可用于单一或多个生产者，多个消费者的场景。在这种场景下，如果生产者尚未产生足够的数据，则消费者可以进入阻塞状态，降低系统性能消耗；当生产者产生可供消费者消费的数据后，则可以使用条件变量唤醒消费者进行消费。线程池就是一个很好的例子。笔者曾实现过一个线程池，但该线程池没有阻塞功能，导致仅减少了新线程创建时的资源开销。 后续的文章会基于条件变量实现一个基于阻塞队列的线程池。","tags":["C++","条件变量"],"categories":["程序设计","语言"]},{"title":"并查集的C++实现","path":"/posts/26/","content":"什么是并查集？ 并查集是一种用于快速在元素之间建立集合关系，并且快速判断两个元素是否属于同一集合的数据结构。其基于的基本假设是传递性：如果元素xxx和yyy属于同一集合，并且yyy与zzz也属于同一集合，那么元素xxx与zzz一定属于同一集合。针对满足这种性质的集合问题，并查集就是一种极其快速的解决方式。 数据结构 并查集基于树的数据结构，每一棵树代表一个集合，每棵树的根节点可以视为这个集合的代表元素。当需要建立新的元素之间的关系时，例如建立aaa与bbb的关系，就将bbb所在的树作为子树加入aaa所在的树中。检查两个元素是否属于同一集合，只需要检查两个元素所在的子树的根节点是否相同即可。 代码实现 以下是并查集的简单代码实现。 具体实现中，我们可以针对每一个元素维护一个parent指针指向其父元素，为方便起见，我们规定：如果一个元素的父节点是它本身，那么该节点就是一棵树的根节点。初始情况下：每个元素自己构成一个集合（即每个元素自己就构成一棵树）。 # includebits/stdc++.husing namespace std;class UnionFindSet private: vectorint parent;public: UnionFindSet(int n) this-parent = vectorint(n, 0); for(int i = 0; i n; i++) this-parent[i] = i; ; 接下来，我们需要完成查找某个结点所在的树的根节点的函数int find(int x)。这个实现是简单的，可以使用循环，也可以使用递归。在这里，我们使用递归的方式来实现之。 class UnionFindSet private: vectorint parent; int find(int x) if(x = n || x 0) return -1; return x == parent[x] ? x : find(parent[x]); public: // UnionFindSet(int n) // ... // ; 这里将其作为私有成员函数的原因是，调用方并不需要知道我们如何维护并查集，find函数也因此只会被我们使用到而已。 接下来就是剩余的附加关系的函数void set_union(int x, int y)和判断是否属于同一集合的函数bool is_unioned(int x, int y)。有了find函数，这两个函数的实现就很简单了。 class UnionFindSet private: vectorint parent; int find(int x) return x == parent[x] ? x : find(parent[x]); public: // UnionFindSet(int n) // ... // void set_union(int x, int y) parent[find(y)] = find(x); bool is_unioned(int x, int y) return find(x) == find(y); ; 时间优化 可以看到，上述实现的并查集的时间开销都集中在find操作上，而find操作的时间复杂度又取决于树的深度。因此，有没有方法可以降低树的深度呢？答案是，在进行find操作时，我们可以将路径上访问过的结点的父节点直接设为最后find结果所代表的根节点。这样，进行一次查找后，被访问过的路径的parent就直接指向了根节点，使得树的深度降低为111。修改find函数如下： class UnionFindSet private: vectorint parent; int find(int x) if(x = n || x 0) return -1;- return x == parent[x] ? x : find(parent[x]);+ return x == parent[x] ? x : parent[x] = find(parent[x]); public: // UnionFindSet(int n) // ... // ; 完整代码 class UnionFindSet private: vectorint parent; int find(int x) return x == parent[x] ? x : parent[x] = find(parent[x]); public: UnionFindSet(int n) this-parent = vectorint(n, 0); for(int i = 0; i n; i++) this-parent[i] = i; void set_union(int x, int y) parent[find(y)] = find(x); bool is_unioned(int x, int y) return find(x) == find(y); ;","tags":["C++","并查集"],"categories":["程序设计","算法"]},{"title":"C++ 手撕线程池","path":"/posts/25/","content":"什么是线程池？ 线程池 (Thread Pool) 的基本概念是，在应用程序启动时创建一定数量的线程，并将它们保存在线程池中。当需要执行任务时，从线程池中获取一个空闲的线程，将任务分配给该线程执行。当任务执行完毕后，线程将返回到线程池，可以被其他任务复用。 在处理某些性能受限的任务时，我们通常会创建新线程来处理该任务，以防止进程被阻塞。这样可以一定程度上提高程序的运行性能；然而，这样的处理方式也存在一个问题：频繁创建并销毁进程也是一个对性能要求较高的操作。线程池就是在这个方面进行了性能优化：我们将已经完成了既定任务的线程保留下来，然后使其直接承接新的任务继续运行。如此一来，处理两个任务时，从原来的 两次线程创建两次线程销毁 变成了 一次创建一次销毁 。在任务数目庞大时，这样的性能开销差异会更大。 线程池的设计方案 在着手实现线程池之前，我们需要了解一个线程池需要由什么构成。首先，我们当然需要 一批线程 ，它们是处理任务的主要成员，就好比工厂中的工人一样。此外，我们还需要一个 任务队列 ：程序将需要完成的任务放入此队列中，而后不再关心这些任务的状态；当线程池中有线程处于空闲状态时，从任务队列中取出一个任务开始执行。最后，我们需要 一组接口 ，使得用户可以无需关注线程池的实现细节，而使用简单的接口来提交任务。线程池中任务调度无需暴露给用户，这也是一种面向对象的思想。 本质上，线程池的组成部分是相对比较简单的。下面的示意图也说明了它们之间的关系。 线程池组成结构 线程池的C++实现 首先，我们需要导入pthread库，该库是C++支持多线程的标准库。在本文中，我们主要使用pthread_create()进行线程创建。 线程对象的运行时状态管理 上面说到过，线程池中需要存在一批线程不断接受任务队列中的任务进行执行。因此，我们需要创建一个用于维护线程状态的结构体TP_WORKER来储存这些信息。我们将该结构体定义如下，相关解释也一并包含在代码中： struct TP_WORKER pthread_t p; // 用于存储线程编号，pthread_t是函数pthread_create()的返回值 ThreadPool* pool; // 用于表示该线程隶属于哪个线程池，为防止我们可能在代码中创建不止一个线程池 bool is_running; bool terminate; // is_running表示线程是否被占用；terminate表示线程是否被终止，设为真则线程会被销毁 TP_WORKER* prev; TP_WORKER* next; // 组成线程链表的指针 TP_WORKER() // 构造函数 TP_WORKER(TP_WORKER* p, TP_WORKER* n, ThreadPool* po) prev = p; next = n; pool = po; ; 在我看来，我们也可以使用一个vector数组来存储线程向量。在代码实现上，或许会稍微简单些；但在此笔者选择使用链表的原因在于其可以很方便地离开链表，而vector数组中删除中间元素会产生大量的元素移动，造成性能消耗。 任务队列设计 首先，我们同样需要一个结构体来描述一个任务。简单来说，一个任务就是 一个带有实参的函数 。在C++中，我们可以通过声明函数指针的方式来获取函数对象，通过声明一个指针来获得函数的实参。然而，在声明函数指针时，我们需要对该指针匹配的函数的返回值和形参列表做出声明。例如我们声明如下的函数指针func： void (*func)(int, int); 则该函数指针只能匹配具有两个int类形参，并且返回值为void的函数。这显然会带来一个问题， 我们无法预先知道待处理的任务的函数形式！ 这是，我们可以选择一个较为取巧的方式，我们指定函数形式为： void* (*func)(void *); 这样，我们对该函数传参时，可以将所有实参包装成一个结构体实例，并传入结构体实例的指针。例如，我们对函数进行如下改写： // 原始函数形式void printEquation(int a, int b) std::cout a + b = a + b std::endl; return;// 改写后的匹配函数指针的方式struct EquationData int _a, _b; EquationData(int a, int b): _a(a), _b(b);void* printEquation(void* params) EquationData* data = (EquationData*)params; std::cout data-_a + data-_b = data-_a + data-_b std::endl; return nullptr; 这样的做法能够使得所有函数都可以写成void* (*)(void *)的类型。由此，我们就能很简单地构造出描述任务的结构体TP_JOB了： struct TP_JOB void* (*func)(void*); void* params;; 线程池中的其它重要参数 在线程池类中，需要一些变量来存储线程池的相关信息，如下列出了这些变量。 class ThreadPool private: // struct TP_WORKER // ... // ; // struct TP_JOB // ... // ; struct TP_CONFIG int _max_job_cnt; // 最大排队任务数 int _cur_thread_cnt = 0; ; TP_WORKER* _tp_worker_list; // 线程链表 pthread_mutex_t _tp_worker_list_mutex; // 线程链表锁 queueTP_JOB _tp_job_queue; // 任务队列 pthread_mutex_t _tp_job_queue_mutex; // 任务队列锁 TP_CONFIG _tp_config; _max_job_cnt表示了线程池的任务队列所能容纳的最多任务数量防止任务堆叠；_cur_thread_cnt储存目前存活的线程数目；_tp_worker_list是线程链表的链表头；_tp_job_queue是任务队列。 上述变量中，_tp_worker_list和_tp_job_queue属于 临界资源 。并发编程中，由于读写变量不是原子操作（由多条CPU指令完成），因此无法防止线程A读出写回过程中线程B不会读出该值，从而导致不一致问题。会被这种情况影响的数据被称为 临界资源 。为了防止不一致的问题，我们引入了读写锁_tp_worker_list_mutex和_tp_job_queue_mutex，在读出前尝试获取该锁，在写回后释放锁来防止不一致问题的产生。 创建线程 创建线程的函数原型为： int pthread_create(pthread_t* restrict tidp,const pthread_attr_t* restrict_attr,void* (*start_rtn)(void*),void *restrict arg); tidp就是指向我们在TP_WORKER中的pthread_t p字段的指针，表示线程号；restrict_attr区分线程的不同属性，一般来说我们直接设为nullptr即可；start_rtn是一个函数指针，也就是我们本节所讨论的 回调函数 ，这是新创建的线程的运行入口点；arg是一个参数指针，作为start_rtn的参数。 在线程池的实现中，我们会使用到上述的方法。接下来，我们实现函数ThreadPool::create_thread()，该函数能够为线程池创建一个新的线程使得其能够完成接取任务、执行任务的工作。 我们在上面提到过，TP_WORKER是用于管理线程状态的类，因此，在创建线程之前，我们需要初始化一个TP_WORKER实例，同时对该实例的成员变量进行初始化，并将新的worker实例加入线程链表中，代码实现如下： bool create_thread() TP_WORKER* worker = new TP_WORKER(); worker-pool = this; worker-terminate = false; worker-is_running = false; // 加入新节点时： worker-next = this-_tp_worker_list-next; if(this-_tp_worker_list-next) this-_tp_worker_list-next-prev = worker; worker-prev = this-_tp_worker_list; this-_tp_worker_list-next = worker; // 计数器加一 this-_tp_config._cur_thread_cnt += 1; /* 注意：此处的 _thread_Callback() 函数我们尚未实现，会在后面进行解释 */ int ret = pthread_create(worker-p, nullptr, _thread_Callback, worker); // if(!ret) return true; 上述代码中主要完成了三件事：1、新建一个TP_WORKER的实例worker，并进行初始化工作；2、将其加入链表之中；3、使用pthread_create()创建了新的线程，并交给worker进行托管。 值得一提的是，这里使用的线程链表为 双向链表， 并且引入了哨兵节点（即_tp_worker_list指向的TP_WORKER实例不具备任何意义）。这种做法只是简化了链表操作期间的边界条件判断问题，具体解释可见这篇文章。 之后，我们着重考虑ThreadPool::_thread_Callback()函数的实现，其作为新建线程的入口点。首先，由于pthread_create()参数限制，该函数的原型必须是void* (*)(void *)。然而，我们考虑这样的问题：该函数作为类的成员函数，我们直接声明为如下形式是不可以的： void* _thread_Callback(void* pvoid) 具体原因在于：在C++中，类的非静态成员函数会有一个隐藏的this指针指向类的具体实例，以便于进行方法调用时能够准确的操作我们希望操作的类实例。因此，上述函数声明实际声明的是如下的函数： void* _thread_Callback(ThreadPool* this, void* pvoid) 这就会产生编译错误了。因此，正确的函数声明应该为： static void* _thread_Callback(void* pvoid) 函数参数pvoid应传入我们为该线程创建的TP_WORKER实例指针，即worker，以便于在运行过程中能够读取自身状态参数。那么接下来的操作逻辑就比较简单了，用伪代码表示为如下形式： while(true) if 自身接取了任务: 完成之 else: if 自己的 terminate 设置为 true: 销毁自身，释放空间 else: 尝试获取一个新的任务，若不存在，则不做任何操作 使用C++实现之，则代码如下： static void* _thread_Callback(void* pvoid) // 需要 static 修饰符以去掉 this 指针 // init TP_WORKER* worker = (TP_WORKER*) pvoid; worker-is_running = false; TP_JOB job; ThreadPool* pool = worker-pool; while(true) // 判断是否要终止线程 if(worker-terminate !worker-is_running) // 将自己从 _tp_worker_list 中剥离 pthread_mutex_lock((pool-_tp_worker_list_mutex)); worker-prev-next = worker-next; if(worker-next) worker-next-prev = worker-prev; pthread_mutex_unlock((pool-_tp_worker_list_mutex)); // 释放内存空间并退出 delete worker; pthread_exit(nullptr); // 判断是否空闲 if(!worker-is_running) // 未运行，尝试获取任务 pthread_mutex_lock((pool-_tp_job_queue_mutex)); if(!pool-_tp_job_queue.empty()) // 获取任务 job = (pool-_tp_job_queue).front(); pool-_tp_job_queue.pop(); worker-is_running = true; pthread_mutex_unlock((pool-_tp_job_queue_mutex)); else // 已有任务，则运行 void* res = job.func(job.params); printRes((int)worker-p, *(int *)res); worker-is_running = false; 完整代码 完整的代码如下，可供读者参考借鉴： 线程池的简单C++实现 #include pthread.h#include iostream#include queue#include vectorusing namespace std;pthread_mutex_t print_mutex = PTHREAD_MUTEX_INITIALIZER;void printRes(int no, int res) pthread_mutex_lock(print_mutex); cout Answer: res Computed by thread: no endl; pthread_mutex_unlock(print_mutex);class ThreadPool private: struct TP_WORKER pthread_t p; ThreadPool* pool; bool is_running; bool terminate; TP_WORKER* prev; TP_WORKER* next; TP_WORKER() TP_WORKER(TP_WORKER* p, TP_WORKER* n, ThreadPool* po) prev = p; next = n; pool = po; ; struct TP_JOB void* (*func)(void*); void* params; ; struct TP_CONFIG int _max_job_cnt; // 最大排队任务数 int _cur_thread_cnt = 0; ; TP_WORKER* _tp_worker_list; // 线程链表 pthread_mutex_t _tp_worker_list_mutex; // 线程链表锁 queueTP_JOB _tp_job_queue; // 任务队列 pthread_mutex_t _tp_job_queue_mutex; // 任务队列锁 TP_CONFIG _tp_config; static void* _thread_Callback(void* pvoid) // 需要 static 修饰符以去掉 this 指针 // init TP_WORKER* worker = (TP_WORKER*) pvoid; worker-is_running = false; TP_JOB job; ThreadPool* pool = worker-pool; while(true) // 判断是否要终止线程 if(worker-terminate !worker-is_running) // 将自己从 _tp_worker_list 中剥离 pthread_mutex_lock((pool-_tp_worker_list_mutex)); worker-prev-next = worker-next; if(worker-next) worker-next-prev = worker-prev; pthread_mutex_unlock((pool-_tp_worker_list_mutex)); // 释放内存空间并退出 delete worker; pthread_exit(nullptr); // 判断是否空闲 if(!worker-is_running) // 未运行，尝试获取任务 pthread_mutex_lock((pool-_tp_job_queue_mutex)); if(!pool-_tp_job_queue.empty()) // 获取任务 job = (pool-_tp_job_queue).front(); pool-_tp_job_queue.pop(); worker-is_running = true; pthread_mutex_unlock((pool-_tp_job_queue_mutex)); else // 已有任务，则运行 void* res = job.func(job.params); printRes((int)worker-p, *(int *)res); worker-is_running = false; public: ThreadPool(int threads_cnt, int max_job_cnt) // 初始化变量 this-_tp_job_queue_mutex = PTHREAD_MUTEX_INITIALIZER; this-_tp_worker_list_mutex = PTHREAD_MUTEX_INITIALIZER; this-_tp_worker_list = new TP_WORKER(nullptr, nullptr, this); this-_tp_config._max_job_cnt = max_job_cnt; this-_tp_config._cur_thread_cnt = 0; // 申请线程数组 for(int i=0; ithreads_cnt; ++i) create_thread(); ~ThreadPool() DestroyThreads(this-_tp_config._cur_thread_cnt); pthread_mutex_lock(_tp_worker_list_mutex); delete _tp_worker_list; pthread_mutex_unlock(_tp_worker_list_mutex); bool create_thread() TP_WORKER* worker = new TP_WORKER(); worker-pool = this; worker-terminate = false; worker-is_running = false; // 加入新节点时： worker-next = this-_tp_worker_list-next; if(this-_tp_worker_list-next) this-_tp_worker_list-next-prev = worker; worker-prev = this-_tp_worker_list; this-_tp_worker_list-next = worker; // 计数器加一 this-_tp_config._cur_thread_cnt += 1; int ret = pthread_create(worker-p, nullptr, _thread_Callback, worker); // if(!ret) return true; bool push_job(void* (*func)(void*), void* params) bool state = false; pthread_mutex_lock(_tp_job_queue_mutex); if(_tp_job_queue.size() this-_tp_config._max_job_cnt) _tp_job_queue.push(TP_JOB(func, params)); state = true; pthread_mutex_unlock(_tp_job_queue_mutex); return state; int getThreadCnt() return this-_tp_config._cur_thread_cnt; int DestroyThreads(int number) pthread_mutex_lock(_tp_worker_list_mutex); TP_WORKER* worker = _tp_worker_list-next; while(number 0 worker) worker-terminate = true; number --; this-_tp_config._cur_thread_cnt --; worker = worker-next; pthread_mutex_unlock(_tp_worker_list_mutex); return getThreadCnt(); ; 更多优化 如同哈希表一样：较小的使用率会导致哈希表的绝大多数空间被浪费；较高的使用率则会使得哈希碰撞变得更加频繁，导致性能下降；对于线程池而言，也有类似的困难：任务数目远大于线程数目的线程池无法及时处理任务队列的任务导致任务队列中充斥大量任务；而线程数目远大于任务数目则会导致大多数线程处于空闲状态，浪费系统资源。因此，动态调整线程池中线程的数目是一个值得优化的点（虽然上述代码中尚未实现，但已经封装了创建和删除线程的函数，读者可以一试之）。 在特定使用情境下，线程池也可作出不同程度的优化：例如，在Java中设定了核心线程数，即使当前有线程空闲，也会创建新的线程来执行任务；反之，如果线程池中的线程数目大于核心线程数，则会依据原先设定的生命周期销毁一部分线程，以此来达到所谓的动态平衡。","tags":["C++","线程池"],"categories":["程序设计","算法"]},{"title":"AC自动机原理与实现","path":"/posts/24/","content":"问题背景 AC自动机是一个解决多模式匹配的问题的典型模型，特别是应用于字符串匹配问题。多模式匹配简单来说就是如下的问题： 多模式匹配问题给定一个字符串数组words和一个文本内容s，找到s中出现的所有属于words中的字符串。 许多编程语言中常用的substr函数（从一个字符串中找到某个子字符串）就是这个问题的一种特殊情况（即words中仅有一种匹配模式）。 字典树 在多模式匹配中，我们如何存储这些模式是首先需要解决的问题：如果使用最简单的存储方法，即将每一个模式都完全存储，那么其占用的空间将会是words中所有单词长度的总和。 在大数量的任务下，这个数字会很恐怖！ 利用树的数据结构，很容易构造出一个较为节省空间的存储方案： 将具有相同前缀的模式的重复部分合并，构造成树的形状。 例如，我们要存储单词hers和his时，就可以如下组织这棵树。我们一般称这棵树为 字典树 。 字典树 显然，在模式数量很大的情况下，这种存储方案能够为我们节省大量的存储空间。构建这棵树的方法也很简单，我们仅需遍历所有模式，在每个模式开始时，从根节点向后查找：如果已有我们需要的子节点，则直接转移至子结点上；否则，创建之。构建字典树所需要的时间复杂度为O(w×l)O(w\\times l)O(w×l)，其中：www是模式长度（彼此可能不一），lll是模式数。 字典树构建的C++代码如下给出，供读者参考（代码说明中对一些内容作出了必要的解释，供读者选择性参考）： 字典树C++实现 struct AC_node AC_node *parent; AC_node *son[26] = nullptr; bool terminal = false; AC_node *fail = nullptr; char data; int depth; AC_node(char d, bool t, AC_node *p, int dep, AC_node *pt) data = d; terminal = t; fail = p; depth = dep; parent = pt; ;class AC_Automaton private: AC_node *root;public: AC_Automaton() root = new AC_node(a, false, nullptr, 0, nullptr); // root-fail = root; AC_node* getRoot() return root; bool addString(string s) AC_node *p = root; for(auto c: s) if(p-son[c - a] == nullptr) p-son[c - a] = new AC_node(c, false, nullptr, p-depth + 1, p); p = p-son[c - a]; // end for p-terminal = true; return true; ;字典树C++实现代码解释 上述代码中，AC_node类是节点的结构体：目前为止，仅需读者知道的成员变量意义如下：变量名意义AC_node *parent指向该节点的父节点的指针AC_node *son[26]指向该节点子节点的指针bool terminal终止标记char data此节点存储的数据int depth此节点位于的深度（根节点为0）上述变量中的son指针数组的大小视字符集大小而变（在本例中，我们仅考虑26个英文小写字母，因此取值26），这样做的好处是我们可以在O(1)O(1)O(1)的时间内知道是否已经存在合适的子节点，若不存在则创建之，在字符集数量不大的情况下，这样做是值得的：我们仅付出了存储字符集个指针空间的代价，换取了高效的查询性能；teminal表示该节点是否属于一个终止节点：在构建字典树时，对每个模式的末尾字符所在的节点赋terminal = true表示该节点代表一个模式的终止。其余变量的含义是显然的，在此不多赘述。 回溯问题 构建好了字典树，我们便要思考如何高效的对文本进行模式匹配。我们不妨思考一个简单的例子，在这个例子中：words = [abcf, bcdg, cdef]，s = abcdef。我们试图匹配这个字符串s，并找到其中出现的所有模式。首先，我们构建字典树如下。 构建字典树 从字符串s开头进行匹配，我们可以一路匹配至abc（如红色矩形所示），因为这都满足第一个模式。 匹配过程 但是，当我们试图匹配d时遇到了麻烦：目前正在匹配的模式的下一个字符并非d而是f，显然不构成匹配。此时，我们需要设计一个回溯策略。怎么样的回溯策略是好的？一个方法是：我们需要将已构成匹配的字符串从头开始删减，直到能够构成新的匹配。 我们暂且不论如何做到这件事，仅在这个例子中，我们可以找到如下两种情况，使得这些匹配能够容纳新的字符d。 能够容纳新字符的匹配 哪种选择是更好的？我们倾向于选择bcd这种匹配，因为它更长。想象一下，如果我们优先选择了短的，但后续出现了字符g，我们将永远错过bcdg这种模式（因为g无法匹配e，导致我们为找到新的可能匹配正试图缩减已匹配的字符串）；反过来的话，这个问题便不再存在了。 于是我们较为形式化地描述这一过程：我们记符号f(u,c)=vf(u,c)=vf(u,c)=v代表从节点uuu匹配了字符ccc从而转移到节点vvv的过程，这个表示方法也成为 转移函数 。 当我们发现f(u,c)f(u,c)f(u,c)不存在（如上述例子中，从abc试图容纳d的方式不存在）时，我们试图缩短uuu代表的字符串，使得其能够容纳字符ccc（上述例子中，我们试图缩短abc来容纳字符d）。能够发现，我们寻找的便是uuu代表的字符串的 最长后缀 （上述例子中，我们找到了abc的最长后缀bc）。我们记uuu代表的字符串的最长后缀为fail(u)fail(u)fail(u)。如果fail(u)fail(u)fail(u)能够容纳字符ccc，则f(fail(u),c)f(fail(u),c)f(fail(u),c)就是我们转移到的新的匹配；否则，我们继续寻找fail(u)fail(u)fail(u)的最长后缀，并尝试使它容纳ccc。 上述步骤循环时，如果我们回溯到了根节点，但根节点也无法容纳ccc（即没有以ccc开头的模式存在，因为根节点实际上不匹配任何字符串），则该字符无法被匹配。我们跳过该字符，并从根节点开始匹配。 构建AC自动机 知道了上述过程，我们就可以构建AC自动机了。我们只需要在字典树上增加一些路径，使得无法构成匹配时，能够回溯到正确的位置。 假设我们需要设置v=f(u,c)v=f(u,c)v=f(u,c)的fail指针，即fail(v)fail(v)fail(v)。也就是说，我们需要找到vvv节点代表的字符串的最长后缀。由于fail(u)fail(u)fail(u)是uuu的最长后缀，如果f(fail(u),c)f(fail(u),c)f(fail(u),c)存在，那么其一定是vvv的最长后缀。否则，我们再试图找fail(u)fail(u)fail(u)的最长后缀fail(fail(u))fail(fail(u))fail(fail(u))，判断f(fail(fail(u)),c)f(fail(fail(u)),c)f(fail(fail(u)),c)是否存在…直到我们回溯到了根节点，且f(root,c)f(root,c)f(root,c)也不存在，那么ccc无法匹配任何模式。 注意，由于上述实际上是一个递归过程，因此我们需要自行处理初始的fail指针。不过这也很容易，第一层的节点的fail指针全部指向root，因为对于单字符的字符串而言，其最长后缀就是空字符串（由root代表）。 下面是根据已有字典树构建fail指针的C++实现。 构建fail指针的C++实现 // struct AC_node // ...// ;class AC_Automaton private: AC_node *root; void childEnque(AC_node *p, queueAC_node* q) for(int i=0; i26; i++) if(p-son[i] != nullptr) q.push(p-son[i]); return; public: // AC_Automaton() // ... // // AC_node* getRoot() // return root; // // bool addString(string s) // ... // void buildFail() queueAC_node* q; // 深度为1的节点入队 for(int i=0; i26; ++i) if(root-son[i]) q.push(root-son[i]); while(!q.empty()) // 队首出队 AC_node *p = q.front(); q.pop(); // 分配失配指针 // 特殊情况1： 深度为1的节点失配指针都是根节点 if(p-depth == 1) p-fail = root; // 将子节点入队 childEnque(p, q); continue; // 否则是普通情况 AC_node* tmp = p-parent-fail; while(tmp) if(tmp-son[p-data - a] != nullptr) p-fail = tmp-son[p-data - a]; break; tmp = tmp-fail; if(!tmp)//说明没找到合适的失配指针 p-fail = root; // 该节点所有子节点入队 childEnque(p, q); // end while ; 匹配过程 完成了AC自动机的构建，我们进行多模块匹配的算法就极其简单了。我们使用一个指针存储目前已匹配的位置uuu，即指向字典树中的某一个节点。对于下一个字符ccc，如果f(u,c)f(u,c)f(u,c)存在，则直接将指针指向f(u,c)f(u,c)f(u,c)即可；反之，指向f(fail(u),c)f(fail(u),c)f(fail(u),c)。 上述操作结束后，检查目前指向的节点的terminal，若为真，则已抵达某个模式字符串的末尾，即匹配成功；反之，继续读入文本的下一个字符，重复上述转移过程。 以下是匹配过程的C++实现。 进行匹配的C++实现 // struct AC_node // ...// ;class AC_Automaton private: AC_node *root; // void childEnque(AC_node *p, queueAC_node* q) // ... // public: // AC_Automaton() // ... // // AC_node* getRoot() // return root; // // bool addString(string s) // ... // // void buildFail() // ... // vectorvectorint searchPattern(string s) AC_node *p = root; vectorvectorint res; for(int i=0; is.length(); ++i) char c = s[i]; while(p != nullptr p-son[c - a] == nullptr) p = p-fail; if(p) p = p-son[c - a]; // 前进一步匹配 // 判断是否匹配了完整的串 if(p-terminal) res.push_back(vectorinti-p-depth + 1, i); else p = root; continue; // end for return res; ; AC自动机的完整模板代码 AC自动机的完整C++模板代码 struct AC_node AC_node *parent; AC_node *son[26] = nullptr; bool terminal = false; AC_node *fail = nullptr; char data; int depth; AC_node(char d, bool t, AC_node *p, int dep, AC_node *pt) data = d; terminal = t; fail = p; depth = dep; parent = pt; ;class AC_Automaton private: AC_node *root; void childEnque(AC_node *p, queueAC_node* q) for(int i=0; i26; i++) if(p-son[i] != nullptr) q.push(p-son[i]); return; public: AC_Automaton() root = new AC_node(a, false, nullptr, 0, nullptr); // root-fail = root; AC_node* getRoot() return root; bool addString(string s) AC_node *p = root; for(auto c: s) if(p-son[c - a] == nullptr) p-son[c - a] = new AC_node(c, false, nullptr, p-depth + 1, p); p = p-son[c - a]; // end for p-terminal = true; return true; void buildFail() queueAC_node* q; // 深度为1的节点入队 for(int i=0; i26; ++i) if(root-son[i]) q.push(root-son[i]); while(!q.empty()) // 队首出队 AC_node *p = q.front(); q.pop(); // 分配失配指针 // 特殊情况1： 深度为1的节点失配指针都是根节点 if(p-depth == 1) p-fail = root; // 将子节点入队 childEnque(p, q); continue; // 否则是普通情况 AC_node* tmp = p-parent-fail; while(tmp) if(tmp-son[p-data - a] != nullptr) p-fail = tmp-son[p-data - a]; break; tmp = tmp-fail; if(!tmp)//说明没找到合适的失配指针 p-fail = root; // 该节点所有子节点入队 childEnque(p, q); // end while vectorvectorint searchPattern(string s) AC_node *p = root; vectorvectorint res; for(int i=0; is.length(); ++i) char c = s[i]; while(p != nullptr p-son[c - a] == nullptr) p = p-fail; if(p) p = p-son[c - a]; // 前进一步匹配 // 判断是否匹配了完整的串 if(p-terminal) res.push_back(vectorinti-p-depth + 1, i); else p = root; continue; // end for return res; ;","tags":["算法","leetcode"],"categories":["程序设计","算法"]},{"title":"【leetcode题解】30.串联所有单词的子串","path":"/posts/23/","content":"题目描述 给定一个字符串s和一个字符串数组words。words中所有字符串长度相同。 s中的 串联子串 是指一个包含words中所有字符串以任意顺序排列连接起来的子串。 例如，如果words = [ab,cd,ef]， 那么abcdef，abefcd，cdabef，cdefab，efabcd，和efcdab都是串联子串。acdbef不是串联子串，因为他不是任何words排列的连接。 返回所有串联子串在s中的开始索引。你可以以 任意顺序 返回答案。 解题思路 首先不妨假定一下字符串s的长度为n，单词列表words长度为l，以及每个单词的长度为w。由于子串由words中的单词以任意顺序排列构成，所以长度是确定的，即w×lw\\times lw×l。那么我们就可以对字串开头进行枚举，而后针对每一个子串，分别统计其中的单词是不是words的一个排列。这样的算法枚举子串开头的时间复杂度是O(n)O(n)O(n)，循环内层的判定的时间复杂度是O(l)O(l)O(l)，算法总的复杂度是O(nl)O(nl)O(nl). 有一个明显的可以优化的点在于，假设子串起始下标为st，则当我们检查完[st, st+wl-1]的子串后，我们下一个检查的子串是[st+1, st+wl]。可以看到，检查第二个子串的过程中，其实一大部分是我们在前一次检查中已经扫描过的值，唯一的变化在于子串起始位置和末了位置产生了一定的偏移。因此，可以考虑滑动窗口的方法。 但在此题中，直接使用滑动窗口似乎没那么好用。究其原因在于当子串左右端点移动时只移动了一个字符，而我们维护的却是以word为单元的出现次数。因此，要使用滑动窗口方法，我们需要将每w个字符视作一个单元；子串端点移动时，也以w个字符为步长进行移动。 当然，由于滑动窗口的出发点是下标为000的位置，这样做会使得我们的子串起始点仅能位于w的整数倍处。一个解决方法是我们枚举所有可能的起始点，即模www的剩余类，这样，子串就可以取到所有可能起始点了。 这般，我们枚举可能起始点的时间复杂度为O(w)O(w)O(w)（即000到w−1w-1w−1），每一次枚举后使用滑动窗口来判断能否构成满足要求的子串，时间复杂度为O(n/w)O(n/w)O(n/w)（因为我们将w个字符视作了一个单元，因此总长度为n/wn/wn/w）。整个算法时间复杂度为O(n)O(n)O(n)。 代码（C++） class Solution // 用于重置哈希表计数器的函数 void reset_map(unordered_mapstring, int mp) for(auto kv: mp) kv.second = 0; return; // 从下标st开始的滑动窗口 void findSubstringAt(string s, vectorstring words, int st, vectorint ans, unordered_mapstring, int target, unordered_mapstring, int mp) int w = words[0].length(), l = words.size(), n = s.length(); int cur = st; while(cur = n - w) string substr = string(s, cur, w); auto it = mp.find(substr); if(it == mp.end()) st = cur + w; reset_map(mp); else mp[substr] ++; while(mp[substr] target[substr]) mp[string(s, st, w)] --; st += w; if(cur - st == w*(l-1)) ans.push_back(st); cur += w; return; public: vectorint findSubstring(string s, vectorstring words) int n = s.length(), l = words.size(), w = words[0].length(); vectorint ans; unordered_mapstring, int target; // 目标每个单词的出现次数 unordered_mapstring, int mp; // 窗口中每个单词的出现个数 for(auto word: words) mp[word] = 0; for(auto word: words) if(target.find(word) != target.end()) target[word] ++; else target[word] = 1; // 对所有可能的出发点，调用findSubstringAt()函数 for(int i=0; iw; ++i) reset_map(mp); findSubstringAt(s, words, i, ans, target, mp); return ans; ; 时空复杂度 时空复杂度","tags":["算法","滑动窗口","leetcode"],"categories":["程序设计","算法"]},{"title":"【游戏简评】重走西游路：《黑神话：悟空》","path":"/posts/22/","content":"写在前面 这篇文章稍微聊聊《黑神话：悟空》，毕竟我也不是专业游戏评测家，只能从玩家角度发表一点观点。 总体评价 IGN给分是8分，论坛对这个分数的评价是比较两极分化的。客观来说我认为应该有9分的水平（不考虑滤镜的话）。总体而言是非常优秀的ARPG类型的游戏，尽管存在一些比较明显的缺点，但就总体质量而言于我来说是满意的。 剧情设计 对于剧情的评价可能见仁见智。《悟空》选取了一共六回的故事做进了游戏里，分别对应六张彼此之间独立的地图。其在游戏流程中没有太多直白的叙事，相对应的，其在每一回结束时有一段质量较高的动画来完整地展示故事的来龙去脉；故事中的细节，玩家则可以通过游戏中的图鉴系统（游戏中称之为影神图）来了解，个人认为还是比较详细的。对于非考据党来说也可以权当看个小故事。 影神图 但就我看来这样的做法有一些缺点：如果玩家没有打完一个boss看一下图鉴的习惯，那么主线就会比较像boss rush。当然这也和《悟空》中较为密集的boss战有关。 不过总体来说，一方面作为《西游记》的改编作品，玩家或多或少对背景故事有所了解；另一方面每一回的动画制作属实是质量极度在线，倒也不是很大的问题。个人比较喜欢第二回黄风岭这种节奏，每到达一个关键节点都会有一段评弹，艺术性上是足够的享受，功能性上也跟进了剧情发展。 地图设计 如果要说这个游戏有什么显著的不足，可能我会把票投给地图设计。玩《悟空》的地图过程中，我倒是不由得直观感受到魂系箱庭设计的成熟。一方面，《悟空》是相对来说的线性流程，必然不能要求有开放世界的自由度；但《悟空》又特别喜欢藏东西，这就导致玩家总希望去一些犄角旮旯企图获得些什么。然而这游戏的空气墙设计属实有点反人类了，看似能走却有空气墙的情况想必只要体验了一定时长的玩家都发现了这个问题。（其实悬崖和峭壁是更好的解决方案，玩家可以很明显看到这条路是行不通的） 另一方面是没有小地图（致敬传奇ACT只狼），至少我玩起来有点晕头转向。地图上引导也不足，很容易导致迷路的问题（我玩起来感觉盘丝洞的引导问题尤其明显，直到我打通关了才发现有一个土地庙都没有开）。 不过值得一提的是游戏的风景确实很好，许多场景都不需要特地凹就能拍出很好看的照片（游戏中设计的打坐地点就能感受出来）。本文的封面就是我在最终地图花果山上随手找的风景。 花果山 B站也有专门做游戏摄影的up拍出来的更加专业的图，有兴趣可以看一眼。 我们要拍黑神话悟空，不能只拍黑神话悟空...【第一期】https://www.bilibili.com/video/BV1vZsceJEHZ/ 战斗表现 先说战斗难度，《悟空》整体来说战斗难度是比较低的，这很大一部分取决于黑猴自己的超强性能（褪色者落泪）。游戏里，黑猴除了普攻、重击和翻滚（闪身），一般还具有四个主动技能和三套棍法。主动技能如隐身术的瞬间移动和超强破隐一击、对绝大多数怪都适用的定身术换取输出或恢复时间，以及功能强大甚至可以针对每一关的关底boss的法宝都大大降低了游戏难度。棍法中劈棍具有超高的爆发输出、立棍具有更安全的恢复环境、戳棍具有瞬发的强削韧换取主动进攻机会。可以说，除了毫无远程手段而言，黑猴基本上把所有你想要、想玩的性能都给你了，具体取决于你想怎么玩。也正是得益于黑猴超强的性能，其战斗演出也很优秀。很多时候你一通乱按没准就看上去很秀了，观赏性很高。因为战斗涉及一部分剧透，我就不放视频推荐了，现在也有很多极具观赏性的战斗视频。 再稍微主观评价一下boss的设计。《悟空》绝大多数boss都没什么难度，有难度的boss也大多放在了隐藏支线里（点名小黄龙超高雷电伤害、杨戬逆天机制），除此之外主线卡了我一下的也就只有最终boss大圣残躯了。但是大圣的设计也很微妙，他的招式基本上都是玩家所能掌握的招式的pro max，是比较好熟悉的。初次之外还有一些隐藏小彩蛋，就留给大家自行探索了。多数boss（尤其是人形态boss）互动感是很强的，基本上是见招拆招，加上完美闪身的视听体验沉浸感还是足够的。 印象比较深刻的毫无体验的怪就是大石敢当，位于花果山的隐藏boss，需要拿到四蕴后解锁。毫无互动性的怪，纯粹为了演出，问题是演出也很无聊，就看着它抡锤子。可能是因为建模很大加上我电脑配置有限，正常战斗疯狂掉帧。好在是没有丝毫难度可言，也没有恶心我太久。 还有一点也是比较严重的，多出现于后期的怪的问题就是读指令。因为设计原因，黑猴的主要输出方式是普通攻击积攒棍势，而后使用棍法打出爆发输出。然而很多怪在后期都会非常离谱地躲过蓄力攻击（这点让我感受最明显的就是杨戬，基本上除了戳棍的瞬发攻击外，其它棍法都会被很离谱地躲掉，甚至在杨戬连招期间也会躲）。还有部分大题型的多动怪（如碧眼金睛兽）非常容易满蓄棍法打空、空中战斗（亢金龙）导致视角朝上看不清地面警示，很容易产生负面体验。 总的来说瑕不掩瑜，恶心人的boss总体来说并不算多，绝大多数boss都提供了很好的交互体验。相反由于《悟空》难度低，倒也可以用离谱的伤害强行灌死boss，也没有那么多坐牢的点。 印象深刻的地方 以下内容涉及剧透。 黄眉 说实话boss战背后那个小模型能进去我是没想到的，确实是让我比较惊喜。战斗难度也不算高，流程紧凑，也第一视角讲明白了天命人与本性相对抗的过程。 战斗设计优秀，创意满分，沉浸感满分。 大圣残躯 伟大，无需多言。BGM响起的时候我想没有人会抑制住激动的情绪。整体战斗难度略高，但属于合适的范围中。大圣的招式也基本就是我们招式的强化版本，背板难度也会小很多。有一个特点是大圣的致命攻击反而是好躲的，很多时候都是被一些派生的小动作剐蹭到，比较考验熟练度和细节处理的。 此外，战斗中的菜单也很惊喜。包括识破立棍、喝药被定身以及被大圣弹反后甩给我们棒子等，都是一些小惊喜。而且这些看似是在嘲讽玩家的菜单也并不会引起玩家不适，一方面是并不致命，另一方面是大圣确实值得。整场战斗相比于攻克强敌更像是比试与交流。 完全满分的战斗设计。 二郎显圣真君 需要解锁所有地图的隐藏地图后解锁。 杨戬整体来说互动还是很强的，也是游戏里为数不多真的需要玩家去一定程度上拆解招式的角色。杨戬能够很好地应对玩家许多强力攻击，包括定身、蓄力重棍以及削韧压制等。战斗演出也很优秀，四阶段不同的打法设计的的确确一步步展现出了这位战力顶峰的大将的英姿。 我个人认为杨戬具有全游戏最强的机制和难度。四管护盾下的韧性和减伤加持以及脱战后盾量自回复鼓励玩家不断发起进攻，但杨戬本身的长连段非常考验玩家的应对策略。同时杨戬也具备一定的杀招导致玩家需要格外注意自身状态防止被秒杀。这个boss也是卡了我挺久的。 个人认为杨戬总体上还是挺不错的，也确实是最具互动性的boss之一。但是四次盾条+主动躲避玩家重棍+在玩家的持续攻击下会强行将玩家踢出一定距离的机制确实是有点夸张？","tags":["游戏","黑神话：悟空"],"categories":["娱乐","游戏简评"]},{"title":"【整活向】一觉起来，Python的class关键字不见了？？？","path":"/posts/21/","content":"“欸？为什么我的编辑器给我的class标红了啊？？？” “你不知道吗？Python的新版本移除了class关键字啊？” “啊？？？” 一个早晨 由于不明原因，我突然没法在Python里使用class关键字了！！！这怎么能够接受呢？我的面向对象编程啊！不行不行，没有class我还怎么写代码！突然，一个声音出现在这小小的房间里。 “哦哈哈哈哈，还记得我吗？” “你是谁？？” “闭包——包——嗷——”神秘人悄然离去，只剩下长长的尾音。 不行！你还我class！ 第一步！模拟类的行为 闭包这位同学有一个神奇的性质，就是它会保存自己所存在的上下文环境。在某种意义上，其可以很大程度模拟面向对象的行为。下面就是一个简单的闭包的例子。 def f(): a = 0 def g(): nonlocal a a += 1 print(a) return gg1 = f()g2 = f()g1()g1()g1()g2()g2()g2() 上述代码的输出如下： 可以看到，g1和g2各自维护住了自己所在上下文中的a的值，并且没有产生干扰。基于闭包的这个特点，我们可以实现一个简单的类。 第二步！造一个简单的类 通过上面的例子可以看到，通过一个函数返回其内部的函数对象就可以简单地构造出一个闭包。因此，我们先搭好框架。比如我们模拟一个Dog类： def Dog(name: str, age: int): def this(): pass return this 上述就是一个极其简单的闭包。通过进行函数调用：dog = Dog(Doge, 5)，我们拿到了Dog()返回的一个函数对象；又由于闭包的性质，该函数对象外层环境中的局部变量name和age又会被维持住，这就构成了一个简单的闭包。 类一般都具有一部分成员函数，或者称为对象的方法。在这里我们也可以这样做。 def Person(name: str, age: int): def self(): pass def to_string(): return fPerson(name = name, age = age) def get_name(): return name def get_age(): return age def set_age(new_age: int): nonlocal age age = new_age def set_name(new_name: str): nonlocal name name = new_name self.to_string = to_string self.get_name = get_name self.get_age = get_age self.set_name = set_name self.set_age = set_age return self 首先，我们不使用this而改为self，这符合我们在Python中一贯的使用习惯。同时，我们声明一系列的方法，包括set_name、get_name等。为了便于调用，我们将这些方法的函数对象绑定到self上，这样，我们就可以使用person.get_name()来进行调用了。简单使用一下： p1 = Person(John, 30)print(p1.to_string())print(p1.get_name())print(p1.get_age())p1.set_name(Alice)p1.set_age(25)print(p1.to_string()) 其结果如下： Person(name = John, age = 30)JohnPerson(name = Alice, age = 25) 哦吼！初具雏形。这还需要class关键字干嘛？想到这里，我端起电脑旁的盐汽水，微微抿了一口。 （至于为什么只是抿了一口，那当然是因为优雅）这时，一个声音在我耳畔响起： “你这算什么？不能继承的类也能叫类？” “你再骂！” 话虽这么说，但是没有继承的类就像没有醋的饺子，总是缺少了一点灵魂的。 第三步！灵魂继承，浇给 我们先拿到两个类： def Animal(self, *args, **kwargs): self.name = kwargs.get(name, Unknown) def to_string(): return fAnimal(name = self.name) self.to_string = to_string return selfdef Dog(self, *args, **kwargs): self.age = kwargs.get(age, 10) def to_string(): return fDog(name = self.name, age = self.age) self.to_string = to_string return self 这两个类都符合我们定义的最基础的类，这里就不多解释了。至于我们为何需要格外加一个self的形参，其在继承中将会起到一个重要的作用。这个例子中，Dog类需要继承Animal类，包括父类的成员变量和成员函数。因此，我们需要对Dog类进行改写。 一种显然的方法是修改Dog类的内部逻辑，使之接受到self形参对应的Animal实例后，依次继承其中的成员变量和成员函数。但这种做法太过臃肿了：如果我们还需要定义一个Cat类，我们是不是也要这要修改Cat类内部呢？这两部分代码是不是几乎一模一样呢？如果我们修改了基类Animal的成员变量，那么我们是不是要修改所有继承自Animal类的类定义呢？ 好在，Python中的装饰器能够帮我们进行这部分的代码复用。我们使用@extend()装饰器来表达继承这类关系，因此上述类定义可以改写成： @extend(None)def Animal(self, *args, **kwargs): self.name = kwargs.get(name, Unknown) def to_string(): return fAnimal(name = self.name) self.to_string = to_string return self@extend(Animal)def Dog(self, *args, **kwargs): self.age = kwargs.get(age, 10) def to_string(): return fDog(name = self.name, age = self.age) self.to_string = to_string return self 其中，@extend(None)表示其为基类，不要继承任何类。因此剩下来的工作就是完成@extend的逻辑。 完成装饰器生成器extend 可以看到，@extend(None)和@extend(Animal)才是装饰器，因此extend只是一个装饰器生成器而已，其应该返回一个装饰器。我们先搭建出大致框架： def extend(super_cls): def decorator(cls): pass return decorator 装饰器decorator的参数是子类cls，返回值应该是被装饰过后的子类，其也是一个类，因此我们继续完善上述代码： def extend(super_cls): def decorator(cls): def decorated_cls(): pass return decorated_cls return decorator 首先，我们需要确定被装饰子类decorated_cls的形参列表。在面向对象编程中，我们初始化子类并不需要传入父类实例，因此，self肯定是多余的形参。因此我们能够确定，返回的被装饰子类形参列表必然不存在self，即decorated_cls(*args, **kwargs)。 那么接下来的逻辑是，我们如何处理原本定义中的self形参？显然，这依赖于该类所继承的父类。如果该类本身没有父类（即基类），那么self显然是空对象；反之，self对应的就是使用参数列表所初始化的父类对象。完成上述逻辑即： def extend(super_cls): def decorator(cls): def decorated_cls(*args, **kwargs): # 对应基类情况 if super_cls is None: return cls(lambda: ..., *args, **kwargs) # 对应子类情况 else: super_obj = super_cls(*args, **kwargs) return cls(super_obj, *args, **kwargs) return decorated_cls return decorator 因此，完整的定义即： def extend(super_cls): def decorator(cls): def decorated_cls(*args, **kwargs): if super_cls is None: return cls(lambda: ..., *args, **kwargs) else: super_obj = super_cls(*args, **kwargs) return cls(super_obj, *args, **kwargs) return decorated_cls return decorator@extend(None)def Animal(self, *args, **kwargs): self.name = kwargs.get(name, Unknown) def to_string(): return fAnimal(name = self.name) self.to_string = to_string return self@extend(Animal)def Dog(self, *args, **kwargs): self.age = kwargs.get(age, 10) def to_string(): return fDog(name = self.name, age = self.age) self.to_string = to_string return self 我们测试一下： dog = Dog(name=Buddy, age=5)print(dog.to_string()) 运行结果： Dog(name = Buddy, age = 5) “嗨，不过如此嘛。”又喝了一口剩下的盐汽水，我长舒一口气。 “哼哼，你以为就结束了？” “不然呢？这个闭包模拟类行为简直是天才想法！” “真的吗？”突然，我的眼前出现了这么一行代码： @extend(Animal, Runner)def Dog(self, *args, **kwargs): pass “我要你做出来多继承！！！” “啊？？” 第四步！多继承，启动！ 理解上述单继承后，多继承的逻辑只需要在extend中修改即可。 def extend(*super_cls_list): # 此时传入的是一个父类列表 def decorator(cls): def decorated_cls(*args, **kwargs): # 对应基类情况(基类情况变更为：父类列表长度为零) if len(super_cls_list) == 0: return cls(lambda: ..., *args, **kwargs) # 对应子类情况 else: # 依次利用参数列表初始化父类，然后将父类的属性绑定到子类super_obj上 super_obj = lambda: ... for super_cls in super_cls_list: cur_obj = super_cls(*args, **kwargs) for k,v in cur_obj.__dict__.items(): if not k.startswith(__): setattr(super_obj, k, v) # 最后利用super_obj初始化self return cls(super_obj, *args, **kwargs) return decorated_cls return decorator 注意此时需要对extend用法稍作修改：对于基类，不再需要传入None；对于子类，需要传入父类列表而不是以逗号隔开的多个参数 完整代码如下： def extend(*super_cls_list): def decorator(cls): def decorated_cls(*args, **kwargs): if len(super_cls_list) == 0: return cls(lambda: ..., *args, **kwargs) else: super_obj = lambda: ... for super_cls in super_cls_list: temp_obj = super_cls(*args, **kwargs) for k,v in temp_obj.__dict__.items(): if not k.startswith(__): setattr(super_obj, k, v) return cls(super_obj, *args, **kwargs) return decorated_cls return decorator@extend()def Animal(self, *args, **kwargs): self.name = kwargs.get(name, Unknown) def to_string(): return fAnimal(name = self.name) self.to_string = to_string return self@extend()def Runner(self, *args, **kwargs): self.speed = kwargs.get(speed, 10) def to_string(): print(fself.name is running with speed self.speed) self.to_string = to_string return self@extend(*[Animal, Runner])def Dog(self, *args, **kwargs): self.age = kwargs.get(age, 10) def to_string(): return fDog(name = self.name, age = self.age, speed = self.speed) self.to_string = to_string return self 试验一下： dog = Dog(name=Buddy, age=5, speed=20)print(dog.to_string()) 结果： Dog(name = Buddy, age = 5, speed = 20) 后记 “小小的class关键字，居然要考虑这么多。”忙活了这么久，终于可以喝完这瓶盐汽水了。 “不对啊，这盐汽水喝不完啊！” 突然，梦醒了。一如既往地打开电脑和VSCode，输入class关键字。 “好像？都是一场梦？” “哈哈哈哈，”古怪的声音再次响起，“但你学会了不少新东西，不是吗？”这声音又一次离去了，只不过这次再未出现过。","tags":["Python","整活向"],"categories":["程序设计","语言"]},{"title":"后量子加密算法系列预告","path":"/posts/20/","content":"听到“后量子加密算法”这个标题，许多人可能会产生许多疑惑：这和量子计算机有什么关系？后量子加密算法包含哪些内容？本系列将阐述密码学的前沿研究方向：后量子密码学。 序言 什么是“后量子加密算法”？ 听到“后量子加密算法”这个名称，许多人会与“量子计算机”迅速联系在一起。当然，这个直观感受是很对的。但是，“后量子加密算法”并不是运行在量子计算机上的加密算法————毕竟若真如此的话，确实离我们实在是有些遥远了。“后量子加密算法”真正的含义是：在量子计算机上难以被破解的加密算法，也即抗量子计算的加密算法。 为什么需要新的算法？ “为什么需要”这个问题往往是新科技或新技术产生的本质原因：需求决定创造。目前，世界上对于量子计算机的研究发展迅速，导致量子计算时代就快要揭开帷幕。我们需要关注的是，量子计算机在某些计算问题上具备远超电子计算机的计算能力。至于这点，我们可以简单地这么想象：电子计算机使用高低电平来储存信息比特，即对于单个存储单位，其非0即1；而对于量子计算机，情况并非如此：量子计算机中每一位称为“量子比特”。每一个量子比特具有三种状态（严格意义上不止三种，但便于理解，我们姑且认为是三种）：本征态0，本征态1以及量子叠加态（两个本征态的线性组合）。正因为量子叠加态的存在，使得我们在某一个比特上可以存储除了0和1之外的信息。因此，经典比特能够完成的计算一定能够在量子比特上完成，反之则未必。 量子计算机其实并不如我们想象的那么万能。目前而言，仅有少量的难以在电子计算机上求解的困难问题而能够被量子计算机简单求解。但很不幸，1994年Shor所提出的能够在量子计算机上实现的一种算法可以在多项式时间内有效地解决大整数分解问题（感兴趣可见论文原文），这正是RSA的基础。现代的签名证书广泛地使用RSA。这也揭示了某些问题在量子计算机上强大地优越性。同时，设计基于新的困难问题的抗量子计算加密算法迫在眉睫。 后量子加密算法 后量子加密算法中，一般基于以下的数学问题构造：基于编码，基于格，基于多变量，基于哈希等。其中，基于格的后量子密码尤为引人注目。NIST的后量子密码算法征集中，绝大多数也都基于格困难问题构造。本系列试图以尽可能少的数学知识，以通俗浅显的方式介绍基于格的后量子密码学。当然，这并不意味着能够毫不费力地看懂。学习任何知识的过程都不可能如喝水般轻松。 系列文章的难度我希望尽可能能够控制在略加思考就能大致理解的程度。 下一节我们将从格的基本概念入手，对加密算法基于的困难问题的背景知识进行初步的把握。","tags":["密码学","后量子"],"categories":["安全","密码学"]},{"title":"《奥日与萤火意志》(Ori and the Will of Wisps)简评","path":"/posts/19/","content":"一周断断续续通关了奥日 2，简单地对这个游戏做个总结。 前言 奥日 2 发售于三年前，最近也是趁着打折入手，花费了 15 个小时通关了一周目。总的来说奥日 2 是一款很不错的游戏，难度合适，画面、音乐出色。下面对每个部分简单评价一下。 评价 画面效果 首先，画面设计绝对没得说，奥日系列一向就是以画面唯美浪漫被大家所熟知的。本文的封面就是奥日 2 游戏封面，大家也可以一起感受一下： 游戏封面 游戏被分为多个场景，每个场景的美术也独具特色。但相同之处在于都将画面的唯美感置于中心位置。 但是，对于少部分玩家，可能难以适应这种光效，会有“光污染”的感受，这点还是见仁见智了。 画面得分：10/10. 音乐效果 奥日 2 的音乐也是一大特色。主题曲以及主题曲的变奏伴随着整个游戏旅途，或紧张，或感伤，气氛渲染充足又不做作。读者可以播放下面的音乐自行感受。画面与音乐的配合使得这款游戏的视听效果已经十分出众。 音乐得分：10/10. 关卡设计 玩游戏主要还是重在游戏体验以及关卡设计上。奥日是一款典型的 2D 平台跳跃游戏。经过奥日 1 的经验，奥日 2 有着及其大量的自动存档点以及很小的死亡惩罚，使得在标准难度下，游戏的难度依然是比较低的。尤其是如果有空洞骑士的体验之后再来游玩奥日，可以说过关还是轻而易举的。 玩家主要需要围绕着二段跳（后期可以使用三段跳），冲刺以及猛击（与场景中的部分物品互动，可以增加一段冲刺效果）来完成地图探索、BOSS 挑战和解密。不过，BOSS 设计总的来说还有进步空间。奥日对于操作失误的过于宽松的容忍导致即使不躲避 BOSS 的攻击，在中后期依然可以较为简单的通过游戏，因此很容易过关以后连 BOSS 的招式都不知道。 但是，逃亡是奥日独具特色的玩法之一。在整个游戏流程中，有多段逃亡任务，节奏紧张而刺激。围绕着前面所提到的基础操作，再由背景音乐和画面的双重渲染下，逃亡的整个流程紧凑且畅快。下面是一个较为困难的逃亡场景，读者可以感受一下。 如果没有逃亡，奥日的关卡设计其实较为普通。但因为有了独具特色的逃亡关卡，使得奥日也能在大量的平台跳跃游戏中脱颖而出。 但缺点也是很显然的：庞大的地图和稀少的传送点导致玩家需要在获得新技能后大量跑图去探索以前无法到达的地方，这也是许多玩家诟病的地方。当然相比于第一作需要玩家手动存档，第二作的自动存档和即时传送还是进步了许多的。 关卡设计得分：8/10. 总结 《奥日与萤火意志》有着无与伦比的音效和视觉表现，使得玩家能够在游玩过程中如同欣赏艺术品一般沉浸于游戏所带来的体验中。关卡难度较低，上手成本低使得入门玩家也可以拥有较好的游戏体验和反馈。游戏特色逃生关卡节奏紧凑，操作重复却不令人无聊厌烦。奥日披襟斩棘拯救灵树、拯救挚友的故事也在画面和音乐的推波助澜之下带给人长久的感动。不过，游戏大量的跑图依然会带来较为烦人的体验，不过相比于游戏的优点，这些缺点也无伤大雅。 综合推荐指数：9.5/10.","tags":["游戏","奥日"],"categories":["娱乐","游戏简评"]},{"title":"原理与实践：详解跨站请求伪造(CSRF)攻击","path":"/posts/18/","content":"为什么不能点击不明来源的链接？其背后的原理又是如何的？这篇文章，就带你走进一种利用恶意链接发起攻击的方式：跨站请求伪造攻击(CSRF)。 一个例子 文章的开始，我想用一个例子来给大家一点直观的感受。 有一天，小明一如既往点开他的邮箱查阅未读邮件，发现了这么一封邮件，上面写着： 甩卖比特币，一个只要998！ 当然，我们都清楚，这几乎确定是一封钓鱼邮件。但是为了能把故事讲下去，我们只能让小明点开这个链接。小明点开链接后，发现不出意外是一个空白页面。小明关掉了这个页面，不再理会这件事情。 直到几个月后的某一天，小明收到了域名赎回的邮件。起初他以为是自己忘记续费了，直到对方开出了600美刀的价格，他才发现域名被转让了！这时，他回到了那个曾经打开过的空白页面，查看了网页的源代码，发现了如下的字样： form method=POST action=https://mail.google.com/mail/h/ewt1jmuj4ddv/?v=prf enctype=multipart/form-data style=visibility: hidden input type=hidden name=cf2_emc value=true/ input type=hidden name=cf2_email value=hacker@hakermail.com/ ..... input type=hidden name=irf value=on/ input type=hidden name=nvp_bu_cftb value=Create Filter/ /form script document.forms[0].submit();/script 稍有HTML知识的读者就会发现，这是一张隐藏的form表单。表单内容是向Gmail发送一个请求创建邮件过滤规则，其规则为将收到的所有邮件转发给hacker@hackermail.com。同时，这个页面有一个自动执行的Javascript，其发送的这个隐藏的表单。这样一分析，我们就不难理解小明都经历了什么了。 这个事情是具有原型的，其为2007年Gmail的CSRF严重漏洞。受害者的经历大家可以点击这里去阅读。 007年Gmail的CSRF严重漏洞 那么，我们不禁要问，这个攻击为什么能够做到？ CSRF原理 简单介绍 CSRF(Cross-Site Request Forgery)漏洞，即跨站请求伪造漏洞，是一种常见的Web应用漏洞。CSRF是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。 这样的定义还是过于抽象了，通俗来讲，就是攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。 攻击者是如何盗用身份的？这就不得不提到现代通信协议中的重要一部分：Cookie和Session机制。 Cookie和Session HTTP协议是一种无状态的协议，对于先后到达的两个请求之间的关系，HTTP并不了解也不关心是否来自于一个用户，它将这两个请求一律当作两个不同的客户端来处理。这样会导致一些麻烦：如果我连续两次访问同一个网站，我是不是还要输入一次密码？或者重新向服务器证明我的身份？Cookie和Session的引入就是为了解决这个问题。 Cookie和Session示意图 上述流程明确地展示了Cookie和Session的作用：用户访问目标网站时，目标网站会试图将一个小型文本文件写入你的浏览器中，这就是Cookie。当你再次访问同一个网站时，浏览器会自动带上这个Cookie以证明你的合法身份；目标网站也能根据你的Cookie选择不同的Session(一般是数据库中的一部分)为你提供定制化的服务。 CSRF攻击原理一图详解 知道了Cookie和Session，那么CSRF的原理就很好解释了。以下以一张图来展示： 一图详解CSRF 首先，攻击者会提供一个“不怀好意”的界面，等待用户上钩。当受害者访问了这个有害界面时，其利用页面中的恶意代码强制用户向某个具有CSRF漏洞的服务器发送请求。这个请求因为是从受害者端发出的，因此会自动带上受害者的Cookie。服务器接收到这个请求后，认为是合法用户的请求进而执行，使得攻击者的计谋得逞。这就是CSRF的大致原理。 CSRF攻击实例 重要提示接下来的示例全部在本地进行。如果你也想要以学习为目的尝试CSRF攻击，请在本地建立靶机，而不要试图攻击别人的网站！ GET型攻击 GET请求是HTTP常用的向服务器发送数据的方式之一，其特点是可以将参数显式地拼接在URL中请求，因此可以用来传递一些短的参数。例如：https://cn.bing.com/search?q=搜索form=QBRE中：就传递了这么两个参数：q和form。但这样的请求方式安全性很弱，其会被浏览器的历史浏览所记录，并且参数也暴露在URL中。 漏洞风险接下来的示例中的示例代码请不要在生产环境使用！ 我们在本地创建一个api来完成转账服务，使用框架为django。其视图函数如下： @csrf_exemptdef transfer(request): if request.method == GET: target = request.GET.get(target) amount = request.GET.get(amount) print(Successfully transferred to .format(amount, target)) return HttpResponse(Transferred successfully by GET!) 上述函数从GET请求中获取两个参数：target和amount，来表示转账对象和转账金额。发起转账的用户信息从用户发来的Cookie中获取。此时我们只需要使用户点击如下样子的链接：http://127.0.0.1:8000/api/transfer/?target=felixamount=10000，用户的10000元就被转账到了felix账户上。 当然，这样的链接很不聪明，因为URL中包含了太多敏感字眼：例如transfer和amount。因此，使用短链接进行伪装是一个很好的想法。更明智一些，我们可以将这个请求放在HTML页面中，例如下面这样的例子： img src=http://127.0.0.1:8000/api/transfer/?target=felixamount=10000 / 攻击者可以使得用户访问自己的恶意页面时返回包含如上img标签的HTML使得自动请求src的资源，进而发出了这个GET请求。从受害者的角度看来，这个页面除了一个加载不出的图片以外，什么也没有。 受害者看到的 页面源代码 当然了，大多数网站都不会用GET请求发送涉及敏感操作的请求。所以这种方式的适用性有限。 POST请求 与GET请求相对应的，是POST请求。POST请求也是HTTP协议中向服务器传递数据的一种方式，该请求向服务器提交/发送要被处理的数据。POST请求的特点包括：相比于GET请求安全性高，其数据存在于请求体中，安全要求高时可以加密；请求数据不会被浏览器记录，也不会被缓存；可以传递的数据量比GET请求高。 这样的请求将发送的数据放在请求体中，如下图所示： POST请求的负载 攻击POST请求的api接口时相较于GET请求并没有复杂多少，因为我们的目的就是利用受害者的Cookie身份。我们依然利用钓鱼链接诱骗用户上当，这个链接依然可以通过前面说的短链接，或者重定向等方式来伪装。页面也可以设置成为一个自动发送的POST表单，其中包含了我们希望受害者做的操作。 后端处理POST请求的代码如下： @csrf_exemptdef transfer(request): if request.method == GET: target = request.GET.get(target) amount = request.GET.get(amount) print(Successfully transferred to .format(amount, target)) return HttpResponse(Transferred successfully by GET!) if request.method == POST: target = request.POST.get(target) amount = request.POST.get(amount) print(Successfully transferred to .format(amount, target)) return HttpResponse(Successfully transferred by POST) return HttpResponse(invalid visit) 恶意页面包含的内容 与小明碰到的情况非常类似，这个页面也自动发送了一个在服务器看来完全合法的表单。这样，POST请求也并没有保证拦截非法请求。那么，CSRF有什么防范措施吗？ CSRF攻击的预防 答案是显然的。不论上述哪种攻击方式，他们有一个共同的特点：**CSRF攻击之所以能成功，是因为攻击者可以完全伪造用户的请求。**只要破坏这个条件，CSRF就是很容易预防的。 常见的防御措施有：验证码、Referer验证、CSRF-token。 验证码 验证码强制用户与网站进行交互，而不能离开交互便获取到所有需要的信息，因此可以用来防范CSRF攻击。但是，验证码的缺点是：其对用户体验的破坏性的。 对用户体验的破坏性 Referer验证 Referer是请求头中的一个字段，其包含了当前请求页面的来源页面的地址，即表示当前页面是通过此来源页面里的链接进入的。服务端可以使用 Referer 请求头识别访问来源。我们发现，伪造的请求大多都来源于攻击者构建的页面，这个信息会被存储在Referer请求头中。后端接收到请求时可以对该字段进行检查，来过滤掉可能是CSRF攻击所伪造的请求。 我们假设服务器的网址：http://127.0.0.1:8000，而攻击者页面的地址：http://127.0.0.1:80，那么显然：正常请求的来源肯定是前者，而后者发来的请求在正常情况下大概率是不会发生的。 Referer字段的不同 CSRF token CSRF token是服务器后端返回页面时自动生成的字符串，一般是随机字符串与时间戳的加密密文。在用户访问该网站时，服务器会产生一个token交给用户；在提交请求时，前端自动携带这个token发送给后端校验，来判断这个请求是否是用户自愿发送的。在django中，我们可以如下设计表单使其带上CSRF token： form method=post action=/api/transfer/ % csrf_token % # csrf token ptarget: input type=text id=target name=target //p pamount: input type=text id=amount name=amount//p button type=submit value=submitSubmit/button/form 此时，前端页面可能没有变化： 貌似没有变化的前端页面 但事实上，表单中多了一个隐藏的字段，就是这个随机的token。 已经嵌入了一个额外的字段csrf-token 现在，许多的网站都选择通过这种方式来防止CSRF攻击，读者可以查看任意一个可以提交数据的网站的页面源码来看看是否有一个csrf token。 结束语 这篇文章通过原理与实践的方式介绍了Cookie和Session的机制、CSRF攻击的原理以及防范措施。当然更重要的，是每个人都要保护好自己的Cookie。Cookie宛如一张“电子身份证”，向网站证明你的身份。Cookie的私密性是非常重要的，因此，定期清楚浏览器中不使用的Cookie也是一个好的习惯。","tags":["Web安全"],"categories":["安全","Web"]},{"title":"Stellar动态友链分组","path":"/posts/17/","content":"我们时常希望博客的友链界面能够对不同的友链分组；stellar的动态友链功能又十分强大，但所有导出的数据都会写入一个文件。这篇文章记录对动态友链生成仓库的改造，使之能够进行友链分类。 11月15日更新最新版本的动态友联已经支持输出到自定义文件，因此读者继续参考本文时请注意文章的时效性。 由于本文对于仓库源码有一定的改动，请先确认你是否确实有这个需求，而后再理性地选择是否魔改。 废话我就不多说了，我们直接开始。 fork动态友链抓取仓库 首先，你需要fork动态友链抓取仓库，链接如下： https://github.com/xaoxuu/issues-json-generatorhttps://github.com/xaoxuu/issues-json-generator 根据README内容完成配置。这里我就不多赘述了，需要保证你的workflow能够正确运行并且output分支能看到输出的data.json文件。 代码修改 在这个魔改中需要修改两部分内容(均处于main分支下)：config.yml和generator/main.py。这里先给出两者的文件： 提示在复制源码前，我建议你看看我都改了什么。这有助于你对代码有宏观的把握，也对程序中可能出现的问题有解决想法。 config.yml diff源文件config.yml# 网络请求设置request: timeout: 10 # 超时设置 ssl: false # ssl设置# 要抓取的 issues 配置issues: repo: felixchen0707/friendLink_api # 仓库持有者/仓库名 label: active # 筛选具有 active 标签的 issue ，取消此项则会提取所有 open 状态的 issue+ className:+ - ordinary+ - top sort: updated-desc # 排序，按最近更新，取消此项则按创建时间排序config.yml# 网络请求设置request: timeout: 10 # 超时设置 ssl: false # ssl设置# 要抓取的 issues 配置issues: repo: felixchen0707/friendLink_api # 仓库持有者/仓库名 label: active # 筛选具有 active 标签的 issue ，取消此项则会提取所有 open 状态的 issue className: - ordinary - top sort: updated-desc # 排序，按最近更新，取消此项则按创建时间排序 generator/main.py diff源文件generator/main.py# -*- coding: utf-8 -*-# author: https://github.com/Zfourfrom bs4 import BeautifulSoupimport osimport requestimport jsonimport configversion = v2outputdir = version # 输出文件结构变化时，更新输出路径版本- filename = data.jsondata_pool = []+ cfg = config.load()+ filter = cfg[issues]def mkdir(path): folder = os.path.exists(path) if not folder: os.makedirs(path) print(create dir:, path) else: print(dir exists:, path)- def github_issuse(data_pool):+ def github_issuse(data_pool, className): print( ) print(------- github issues start ----------)+ print(is catching label: + className) baselink = https://github.com/- cfg = config.load()- filter = cfg[issues] try: for number in range(1, 100): print(page:, number) url = https://github.com/ + filter[repo] + /issues?page= + str(number) + q=is%3Aopen if filter[label]:- url = url + +label%3A + filter[label]+ url = url + +label%3A + filter[label] + +label%3A + className if filter[sort]: url = url + +sort%3A + filter[sort] print(parse:, url) github = request.get_data(url) soup = BeautifulSoup(github, html.parser) main_content = soup.find_all(div, aria-label: Issues) linklist = main_content[0].find_all(a, class: Link--primary) if len(linklist) == 0: print( end) break for item in linklist: issueslink = baselink + item[href] issues_page = request.get_data(issueslink) issues_soup = BeautifulSoup(issues_page, html.parser) try: issues_linklist = issues_soup.find_all(pre) source = issues_linklist[0].text if in source: source = json.loads(source) print(source) data_pool.append(source) except: continue except Exception as e:- print( end)+ print( end catching label: + className)print(------- github issues end ----------)print( )# 友链规则+ for className in filter[className]:+ data_pool.clear()- github_issuse(data_pool=data_pool)+ github_issuse(data_pool=data_pool, className=className) mkdir(outputdir)- full_path = outputdir + / + filename+ full_path = outputdir + / + className + .json with open(full_path, w, encoding=utf-8) as file_obj: data = version: version, content: data_pool json.dump(data, file_obj, ensure_ascii=False, indent=2)generator/main.py# -*- coding: utf-8 -*-# author: https://github.com/Zfourfrom bs4 import BeautifulSoupimport osimport requestimport jsonimport configversion = v2outputdir = version # 输出文件结构变化时，更新输出路径版本data_pool = []cfg = config.load()filter = cfg[issues]def mkdir(path): folder = os.path.exists(path) if not folder: os.makedirs(path) print(create dir:, path) else: print(dir exists:, path)def github_issuse(data_pool, className): print( ) print(------- github issues start ----------) print(is catching label: + className) baselink = https://github.com/ try: for number in range(1, 100): print(page:, number) url = https://github.com/ + filter[repo] + /issues?page= + str(number) + q=is%3Aopen if filter[label]: url = url + +label%3A + filter[label] + +label%3A + className if filter[sort]: url = url + +sort%3A + filter[sort] print(parse:, url) github = request.get_data(url) soup = BeautifulSoup(github, html.parser) main_content = soup.find_all(div, aria-label: Issues) linklist = main_content[0].find_all(a, class: Link--primary) if len(linklist) == 0: print( end) break for item in linklist: issueslink = baselink + item[href] issues_page = request.get_data(issueslink) issues_soup = BeautifulSoup(issues_page, html.parser) try: issues_linklist = issues_soup.find_all(pre) source = issues_linklist[0].text if in source: source = json.loads(source) print(source) data_pool.append(source) except: continue except Exception as e: print( end catching label: + className)print(------- github issues end ----------)print( )# 友链规则for className in filter[className]: data_pool.clear() github_issuse(data_pool=data_pool, className=className) mkdir(outputdir) full_path = outputdir + / + className + .json with open(full_path, w, encoding=utf-8) as file_obj: data = version: version, content: data_pool json.dump(data, file_obj, ensure_ascii=False, indent=2) 如何配置className 在我的构想中，一个网站应该由两部分构成：网站状态和网站分类。前者通过active、404、suspend这类的label进行标记；后者则是你自定义的分类。 对于你自定义的分类名称，你需要写在config.yml中的className项中，例如我这里用ordinary和top来区分一般友链和置顶友链。经过配置后的className包含的元素会在执行action的时候依次被作为label单独抓取合适的友链，例如下图是我的友链仓库： 我的友链仓库 其中，标记为active的issue表示允许被抓取，而标记为top和ordinary的issue会在抓取top和ordinary的两批抓取中分别被抓取，来达到对友链分类的效果。 期望的运行结果 被标记为classA的友链将会输出至output分支下v2/classA.json文件中，其他情况类似。由于label的名字与输出文件的名字强相关，这也要求你不要用奇怪的符号作为label的内容。 一些些补充 每个issue对应两个label 由于我使用站点状态和站点分类来分别表示一个网站，因此每一个issue至少都有两个label标记。例如，你的config.yml中配置了： config.ymlissues: label: active 若你仅仅为一个issue打上了ordinary标记而没有加上active标记或者反之，则该issue都不会被读取到。 加快访问速度 由于直接访问github的速度极慢，你可以使用Vercel构建该仓库来达到加速访问的效果。在你的Vercel的面板界面(dashboard)新建项目，导入你的友链数据仓库并点击deploy。由于你的输出内容一般不在main分支但是Vercel却会默认构建main分支，你需要进行以下操作： 点开项目，进入Settings-Git界面，找到Production Branch配置项，将分支名称从main/master改成output。下次向output分支推送时，Vercel就会重新改为部署该分支了。 致谢 xaoxuu/issues-json-generator BeaCox的灵感","tags":["博客"],"categories":["博客"]},{"title":"利用Github Action部署博客","path":"/posts/16/","content":"前言 刚开始建立博客的时候，我一直采取的是本地hexo g后hexo d推送到Github的仓库中。这是利用hexo搭建博客最简单的部署方式。然后后续发现，源文件在这种情况下很容易丢失，备份的话又显得比较麻烦。后来了解到Github Action的强大功能，加上阅读了这篇教程后，现在已经实现将源文件推送到某个Github仓库，而后由仓库自动执行Github Action推送静态文件到另一个仓库(一般是我们的.github.io仓库)来代替我们在本地完成hexo g -d操作，同时也能托管我们的源文件。由于上面那篇教程年代有些许久远，这篇文章主要提供能够直接抄作业的workflow供大家使用。 操作步骤 创建需要用到的仓库 首先需要创建两个仓库，一个用于存放源文件，另一个存放生成的静态文件。以我的为例，用felixchen0707/MyBlogSourceCode存放源文件，用felixchen0707/MyBlog存放静态文件。 提醒值得注意的是，你也可以在同一个仓库中创建两个分支，在两个分支中分别存放源文件和静态文件。但并不推荐这么做，因为若这样做，也就意味着你的源文件和静态文件只能同时为public或者private，而且github仓库数目也并没有那么紧张，分开存放利远大于弊。 生成密钥 由于对仓库的写入需要特别的权限，因此你需要生成密钥对。在bash键入如下命令： 你可以在当前文件夹下看到两个文件，分别为github-deploy-key和github-deploy-key.pub，前者为私钥，后者为公钥。 注意请务必保证私钥的保密性。 为仓库配置公钥和私钥 源文件仓库 首先前往源文件仓库配置私钥。在我提供的例子中，其为felixchen0707/MyBlogSourceCode。 源代码仓库 如上图所示，为其新建一个secret，名称为HEXO_DEPLOY_PRI，内容为github-deploy-key文件中的全部内容(全选Ctrl+A)。 静态文件仓库 然后，前往静态文件仓库配置公钥。在我提供的例子中，为felixchen0707/MyBlog。 注意如果使用Github Pages托管可供访问的网站，这个仓库必须是你的用户名.github.io，以我为例，即felixchen0707.github.io。 静态文件仓库 如上图所示，添加Deploy Keys。Title为HEXO_DEPLOY_PUB，内容为文件github-deploy-key.pub的全部内容。同时，勾选下方的Allow Write Access来提供写入权限。若你没有勾选此选项，该密钥对没有写的权限。 注意这里添加的是Deploy Keys而非Secrets，一定不要搞错。 添加Workflow workflow模板 接下来，在你的博客根目录下新建一个文件夹，名为.github，其中存放的文件可以被github识别并且加以利用。新建.github/workflows/auto_deploy.yml编写workflow模板。其内容如下： # /.github/workflows/auto_deploy.ymlname: CIon: push: branches: - masterenv: GIT_USER: felixchen0707 GIT_EMAIL: 3137181992@qq.com THEME_REPO: felixchen0707/hexo-theme-stellar THEME_BRANCH: main DEPLOY_REPO: felixchen0707/MyBlog DEPLOY_BRANCH: mainjobs: build: name: Build on node $ matrix.node_version and $ matrix.os runs-on: ubuntu-latest strategy: matrix: os: [ubuntu-latest] node_version: [16.x] steps: - name: Checkout uses: actions/checkout@v2 - name: Checkout theme repo uses: actions/checkout@v2 with: repository: $ env.THEME_REPO ref: $ env.THEME_BRANCH path: themes/stellar - name: Checkout deploy repo uses: actions/checkout@v2 with: repository: $ env.DEPLOY_REPO ref: $ env.DEPLOY_BRANCH path: .deploy_git - name: Use Node.js $ matrix.node_version uses: actions/setup-node@v1 with: node-version: $ matrix.node_version - name: Configuration environment env: HEXO_DEPLOY_PRI: $secrets.HEXO_DEPLOY_PRI run: | sudo timedatectl set-timezone Asia/Shanghai mkdir -p ~/.ssh/ echo $HEXO_DEPLOY_PRI ~/.ssh/id_rsa chmod 600 ~/.ssh/id_rsa ssh-keyscan github.com ~/.ssh/known_hosts git config --global user.name $GIT_USER git config --global user.email $GIT_EMAIL - name: Install dependencies run: | npm install - name: Deploy hexo run: | npm run deploy 现在对上述模板做出解释。name为workflow的名称，这是任意的。 触发时机 on: push: branches: - master 以上为workflow触发的时机，即当master分支有新推送时触发。这里是否是master由你的源文件仓库分支名决定，若为main，则你需要修改成： on: push: branches: - main 环境变量 env: GIT_USER: felixchen0707 GIT_EMAIL: 3137181992@qq.com THEME_REPO: felixchen0707/hexo-theme-stellar THEME_BRANCH: main DEPLOY_REPO: felixchen0707/MyBlog DEPLOY_BRANCH: main 以上为workflow运行期间的变量，各个值需要你重新设置。GIT_USER为你的Github名称，GIT_EMAIL为你的邮箱，上述两者为触发workflow部署时的提交信息内容。 THEME_REPO和THEME_BRANCH指定了你的博客主题，在workflow运行时会自动拉取主题代码。我强烈建议你fork一份主题仓库来避免主题仓库更新时配置文件落后的情况发生。 DEPLOY_REPO和DEPLOY_BRANCH指定了向何处推送生成的静态文件。这里即为你一开始创建的存放静态文件的仓库。 定制jobs jobs: build: name: Build on node $ matrix.node_version and $ matrix.os runs-on: ubuntu-latest strategy: matrix: os: [ubuntu-latest] node_version: [16.x] steps: - name: Checkout uses: actions/checkout@v2 - name: Checkout theme repo uses: actions/checkout@v2 with: repository: $ env.THEME_REPO ref: $ env.THEME_BRANCH path: themes/stellar - name: Checkout deploy repo uses: actions/checkout@v2 with: repository: $ env.DEPLOY_REPO ref: $ env.DEPLOY_BRANCH path: .deploy_git - name: Use Node.js $ matrix.node_version uses: actions/setup-node@v1 with: node-version: $ matrix.node_version - name: Configuration environment env: HEXO_DEPLOY_PRI: $secrets.HEXO_DEPLOY_PRI run: | sudo timedatectl set-timezone Asia/Shanghai mkdir -p ~/.ssh/ echo $HEXO_DEPLOY_PRI ~/.ssh/id_rsa chmod 600 ~/.ssh/id_rsa ssh-keyscan github.com ~/.ssh/known_hosts git config --global user.name $GIT_USER git config --global user.email $GIT_EMAIL - name: Install dependencies run: | npm install - name: Deploy hexo run: | npm run deploy 上述为workflow的具体流程，有几个部分值得你注意。 nodejs版本 不同的主题对于nodejs有不同的版本要求，你需要在node_version: [16.x]设置，此处是nodejs最新的稳定版本，能够满足大多数主题要求，当然，你可以指定你需要的版本。 拉取主题代码 - name: Checkout theme repo uses: actions/checkout@v2 with: repository: $ env.THEME_REPO ref: $ env.THEME_BRANCH path: themes/stellar 上述步骤中，Github会拉取主题代码，仓库已由THEME_REPO和THEME_BRANCH决定。其中，你需要修改path的值，若为themes/stellar，则相当于将主题代码拉取至/themes/stellar下。需要注意的是，这里要和你的站点配置文件_config.yml中如下配置保持一致： # Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: stellar 添加.gitignore 此时，你只需要在博客根目录下键入： 将其初始化成为一个Git仓库。但提交时，有些文件是多余的，你可以将其写入.gitignore中，以下是一个例子： .gitignorenode_modules/themes/db.json 然后提交并指定分支： 然后绑定远程仓库： 最后推送即可： 常见问题 插件版本的更新 虽然我们并没有提交node_modules文件夹，但我们推送了package.json和package_lock.json。两个文件详细记录了我们下载的插件及他们各自的依赖，在执行workflow时，action会自动collect这些包；如果我们对于这些依赖包有更新的需求，可以配置dependabot，在如下位置开启它： dependabot启用位置 此时，.github下会生成如下文件： .github/dependabot.ymlversion: 2updates:- package-ecosystem: npm directory: / schedule: interval: daily open-pull-requests-limit: 20 插件的更新会通过pr的方式告知你，你只需要merge即可。 或者你可以在本地升级插件版本，重新推送。 建议建议推送前先使用hexo s预览，因为例如hexo-abbrlink这类插件会在预览或生成站点时在MarkDown文件的头部增加新的键值对。 workflow运行提示action_bot无权限怎么办 请检查你是否安装了hexo-deployer-git插件，并且在配置文件中是否采取了ssh而非http连接： _config.yml# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: type: git repo: git@github.com:felixchen0707/MyBlog.git branch: main 我这么做还有什么好处？ 首先正如一开始所说的，你可以在部署时同时备份你的源文件。利用Action来部署站点，也使得你的本地环境并不依赖nodejs环境，例如你需要修改小错误时，完全也可以在手机上做到。当然，也并不是说利用Github Action部署就一定优越，大家可以按需食用。","tags":["博客"],"categories":["博客"]},{"title":"我的大一","path":"/posts/15/","content":"可能是想利用闲下来的功夫哔哔点啥。 前言 大一的生活比我想象的更快，加上一直不间断的疫情，大一后半段的生活似乎也就是在食堂和寝室两点一线中结束的。由于能看到这个博客的人要不就是在现实生活中与我毫无接触，要么就是无话不谈的好朋友，所以也不害怕暴露少部分的个人信息了。大一的各种琐事也都在最近渐渐收尾，不如自己来总结一下吧。 第一次早八 看到2022级同学入学时令我佩服的精气神，我也不由得想起自己刚进入大学时的样子。许多细节我其实也记不太得，但是印象深刻的还是开学的第一堂高数课。那是我的第一个早八。早上大概七点二十分左右，整整五百人的大教室就快坐满人了，现在想想这个点我刚醒吧（笑）。其实当时我也是这些疯狂的人之中的一员。说起动机，也未必是对知识的渴求，而是对新生活环境的好奇。毕竟在高中，可能一屁股坐在凳子上以后都不怎么离开位置吧，跟大学课间跑课不能说一模一样，就是毫不相关。坐在教室里，看着周围新奇的环境和陌生的课本，有一瞬间觉得高中所付出的辛苦都是值得的。不得不说，一个还算可以的高考成绩确实把我送进了理想的学府，让我感受到了梦寐以求的环境和氛围。虽然第一节高数课确实把我心态搞炸了，但是当时的我，确实表现出了前所未有的积极向上。 我的高数破防时刻 专业预选 出于某些懂的都懂的原因，我们学校对于工科专业是一起招收，入学后再进行二次分流。或许现在看来，这并不是什么稀奇事了，这种招生方式只会越来越广泛地被采取。但对于当时的我来说，简直就是噩梦。现在我依稀记得综评出分的那天晚上，我失眠了。我尽可能的从各种途径寻找能去信息安全的最低分数，甚至让原本不喜欢询问别人的我去加学长联系方式询问一些信息。其实我自己很清楚，这些努力基本上都是徒劳的，高考分数已然决定了我的去向，并不是我能够改变的。最后只能填了适合我这个分数段所能选择的我认为最有兴趣和前景的专业———生物医学工程。我记得很清楚，公布预选结果的时候我正在上大学化学这门课程，我整个暑假都在惦记的事情终于落地，似乎也没有那么焦虑和忧郁了。 仔细想想我很多时候都是这个样子，其实很清楚自己的未来会朝着什么样的地方发展，但却依旧忧心忡忡。我并不害怕差的结果，但我害怕未知。 不确定性是我一直很厌烦的事情。对于这个结果，后来我也很平静地接受了，虽然这本不是我最期望的结果。但站在现在的时间点，必须承认的是，我确实在生医工学院度过了值得我深深记住的大一学年。 大一下 虽然接受了分流结果，但我依然努力寻找进信安的方式，大二上的专业调整是我唯一的机会。经过大一上一学期的学习，我的年排最终锁定在8/80.这是一个还算不错的成绩，但对于转信安来说，还是有点痴人说梦了。但是大一下，我们有转出平台的机会，换句话说，就是可以离开工科平台，去学其他的专业。因为疫情，金融专业放弃了面试考察，转而采取更为简单粗暴的按排名由高到低录取。这对我来说是个不小的诱惑。 当你无法选择自己喜欢的专业时，碰上宇宙金这个专业至少能保证不错的出路。 而对于我的排名，被成功录取的概率是很大的。当时我便在转出或等待大二上两个选择中纠结，毕竟后者有赌的成分。这也就是我0624这篇碎碎念的来源。如果将现在的我放在当时的情境下，即便过去五个多月，我依然不能给出准确的选择。但现在的我又很庆幸，当时的我没有因为眼前的另一条道路而选择退缩。 在我看来，尝试后的失败比自我放弃的失败更加值得尊敬。 我在生医工学联 整个大一的我基本都是围绕学积分在转，因此对于大学生活的多样和丰富我几乎没有什么感觉，反而是时常陷入焦虑的旋涡中。但唯一有一个选择是我从未后悔的，就是加入生医工的院学联。在这里，我真真切切感受到了社交间的温暖。许多人都曾在我面前抱怨过学生组织内部的腐烂，但对我而言，生医工学联带给我的是如同第二个家一般的温暖。由于院系小的缘故，学院每月都有固定的生日会，为当月生日的同学准备蛋糕；学联的同学们也经常性冒出很有想法的活动点子，使得我们学院看上去像是天天在搞活动；各部门内部的例会硬生生会被我们组织成团建的样子。诸如此类，还有很多。在这里，我确实认识了一帮很有意思的人们，以及很优秀的值得尊重的其他同学。我想如果有什么是让我依旧怀念的，生医工团学联可能占据了很大一部分。 大一结束 如今，虽然已经到了大二第一学期期中了，但我大一所担心的一切事物，都才刚刚结束。我达到了我一年前想都不敢想的高度，也为我日日胆战心惊所焦虑的事情交出了还算不错的答卷。我转去了我当初心心念念的信息安全，选拔上了金融的辅修，也在生医工的学联完成了我完完全全策划一场活动的梦想。我开始真正接触信息技术，我认识了一大批值得尊敬的同学，我遇上了不少我可能这辈子都不会忘记的教授。走上一个新的阶段，就意味着过去的一切已经被慢慢封存，而未来的路还等着我慢慢开辟。我可能会陷入新的痛苦，也有可能收获新的喜悦；我可能会受到挫折的历练，也可能体会到苦尽甘来的惊喜。不论如何，很多事都要我自己去闯。 未来的好坏我无法预知，但未来一直在我的手中。","tags":["碎碎念"],"categories":["杂谈"]},{"title":"记录第一次手搓css","path":"/posts/14/","content":"手搓一次 css 以后，最大的感受就是：再也不想写 css 了。 起因 事情的起因是，Bowen跟我说，他用 tailwindcss 重新写了个主页，后来效果确实不错。看了看自己的主页，感觉有点太花里胡哨了。其实早些时候我特别喜欢花里胡哨，现在可能年纪大了吧。 后来看到了一位巨佬的主页，简洁得深得我心()。于是便仿照着极简的风格准备手搓。 困难 遇到的困难是，我在这之前 从来没有写过css。键盘上写下的每一行代码都是我最后的倔强。什么margin啊，display啊，彻底把我击垮了。问题在于，我甚至不能参考那位大佬的源码，用 react 写完生成的代码，甚至连一个 css 都没有。 接着就是各种翻手册、一点点尝试、打开各种连接找各种可能的解决方法。终于做出了初版： 初版效果 事情本该到此结束了，这个风格好看也算不上，但说丑也不至于(?)。但在手机端这个效果真的是拉垮，后来才发现，我所有的宽度什么的设置全部用了px。大寄特寄了属于是。 后来 凌晨一点，揉着眼睛把 css 全部换了百分比，用 Bowen 的话说就是： 最简单的响应式 一想确实如此，低级是低级了点，反正一般人看前端也看不到我的代码(bushi)。 结果 现在已经正式作为个人主页啦！感觉效果还不错，很干净。能力不支持复杂了不管怎么说也是第一次从零开始写 css，还是比较满意的。","tags":["css"],"categories":["程序设计","框架"]},{"title":"在django中实现websocket","path":"/posts/13/","content":"本文在 django 中实现 websocket 协议。 在 django 中使用 websocket 纯净的 django 是不支持 websocket 的，要想实现 websocket 协议，我们需要更改一些配置。 Step1: 安装第三方包 第三方包channels提供了在 django 中实现 websocket 通信协议的方式。我们安装这个包： 然后，我们前往settings.py下注册这个 app： INSTALLED_APPS = [django.contrib.admin,django.contrib.auth,django.contrib.contenttypes,django.contrib.sessions,django.contrib.messages,- django.contrib.staticfiles* django.contrib.staticfiles, # MyApp- channels ] 一定要注意这里的逗号，千万不要遗漏，否则 django 会将没有被逗号分隔开的两个应用视作一个应用。 Step2: 配置 asgi 前往项目的settings.py下配置 asgi： WSGI_APPLICATION = ProjectName.wsgi.application- ASGI_APPLICATION = ProjectName.asgi.application 然后前往asgi.py下更改默认配置，删除全部内容改写为： ASGI config for Project0728 project.It exposes the ASGI callable as a module-level variable named `application`.For more information on this file, seehttps://docs.djangoproject.com/en/4.0/howto/deployment/asgi/import osfrom django.core.asgi import get_asgi_applicationfrom channels.routing import ProtocolTypeRouter, URLRouterfrom . import routingsos.environ.setdefault(DJANGO_SETTINGS_MODULE, ProjectName.settings)application = ProtocolTypeRouter(http: get_asgi_application(), # http 路由列表websocket: URLRouter(routings.websocket_urlpatterns), # websocket 路由列表) Step3: 配置路由和视图类 在settings.py同级目录下新建routings.py，其功能相当于urls.py，专门负责 websocket 协议的路由： routings.pyfrom django.urls import pathfrom 应用名称 import consumerswebsocket_urlpatterns = [path(URL, consumers.视图类.as_asgi()),] 然后，前往需要使用到 websocket 的应用下新建consumers.py，其功能相当于views.py： from channels.generic.websocket import WebsocketConsumerfrom channels.exceptions import StopConsumerclass 类名(WebsocketConsumer): def websocket_connect(self, message): # 客户端发来链接请求后自动执行 # 允许创建链接 self.accept() def websocket_receive(self, message): # 客户端发来数据后自动执行 pass def websocket_disconnect(self, message): # 客户端断开wb链接时自动触发 # print(断开连接) raise StopConsumer() 以上是默认的结构，当然，你可以在routings.py中配置多个路由，然后在consumers.py中声明多个类。 运行程序并检查 此时我们运行程序，发现控制台输出变成了： August 02, 2022 - 16:12:48Django version 4.0.6, using settings Project0728.settingsStarting ASGI/Channels version 3.0.5 development server at http://127.0.0.1:8000/Quit the server with CTRL-BREAK. 说明此时 django 项目同时支持 http 协议和 websocket 协议了。 前后端数据交互 后端 后端对于 websocket 的操作相对较少，大多是对于数据的处理。主要用到的是self.send()和self.close()。 self.send()，向建立连接的客户端发送数据，参数即为准备发送的数据。 self.close()，服务端主动与客户端关闭连接。该函数被执行后，需要追加return停止函数继续运行。客户端接收到断开连接的请求后，客户端断开连接，同时，由于断开连接，服务端会自动执行websocket_disconnect()函数，然后抛出异常StopConsumer()，终止 websocket 连接。 前端 创建 websocket 连接 前端可以主动与目标 url 创建 websocket 连接。首先需要新建一个WebSocket对象，初始化参数是目标 url。 ws = new WebSocket(ws://127.0.0.1:8000/room/123/); 该请求匹配到后端的路由： path(room/int/,consumers.ChatRoom.as_asgi()) 于是执行 consumers.pyclass ChatRoom(WebsocketConsumer):def websocket_connect(self, message):self.accept() # 执行这句语句，即连接创建成功 此时，前端可以使用ws.send()发送数据了。 回调函数 当发生连接请求、传递数据、断开连接请求时，后端都有对应的函数会自动执行，前端也如此。这被称为回调函数。回调函数在满足条件后自动触发，JavaScript 中可以为 websocket 绑定三种回调函数。 如果ws是 websocket 的一个实例化对象，那么可以使用ws.onopen、ws.onmessage、ws.onclose绑定函数。例如： ws.onmessage = function(event)let tag = document.createElement(div);tag.innerText = event.data;document.getElementById(msg).appendChild(tag);console.log(已展示最新数据); 上述函数在后端主动发送数据后被自动执行，结果是向 id 为msg的块级内容写入新的元素。其中，event封装了后端发送的所有数据，利用event.data可以提取出数据。 更多地，onopen发生在建立连接后，onclose发生在收到后端关闭连接请求后。 多客户端的管理：聊天室为例 更改配置文件 使用 channel_layers，可以对同时连接的多个客户端进行管理。相关的数据需要被写入内存当中，因此需要在配置文件中添加： settings.pyCHANNEL_LAYERS = default: BACKEND: channels.layers.InMemoryChannelLayer, 将新连接的客户端写入内存中 我们需要将新建立的连接写入内存。对实例对象调用channel_layer.group_add()方法。例如： from asgiref.sync import async_to_syncdef websocket_connect(self, message): # 将连接加入组中，self.channel_name 表示在该组中该连接的名称。async_to_sync(self.channel_layer.group_add)(加入的组名, self.channel_name) 其中，由于上述方法只支持异步，然而我们并没有编写异步代码，因此需要使用同步的方式完成该操作。asnyc_to_sync是将方法由异步转变成为同步。 获得新消息时，对同一组内所有连接群发消息，可以使用group_send()完成。例如： def websocket_message(self, message): # 对组名中所有连接对象调用方法名所对应的方法，字典作为参数传入async_to_sync(self.channel_layer.group_send)(组名,type: 方法名,message: message) 如果方法定义为： def 方法名(self, event):self.send(event[message][text]) 也就意味着对群组内所有连接都发送message['text']。 断开连接时，需要从组内同时剔除该连接。可以使用： def websocket_disconnect(self, message):async_to_sync(self.channel_layer.group_discard)(组名, self.channel_name) 这样，当连接终止时，自动触发websocket_disconnect，该连接就从 group 中被剔除了。","tags":["django","python","websocket"],"categories":["程序设计","框架"]},{"title":"django笔记(4)：为ModelForm表单添加样式、如何拼接GET参数","path":"/posts/12/","content":"为 django 中的 modelform 添加样式。 写在前面 最近的开发学习碰到了两个比较重要的知识点：ModelForm 表单和后端 URL 拼接。这两点不算太难但也比较复杂，并且在后续开发也很常用。常不常用我不知道，反正我第一次是写懵了所以在这里总结一下这部分知识点。 正文 ModelForm 表单 得益于 ModelForm 表单，我们不必在前端写复杂的 html 代码来实现表单。我们只需要一个简单的循环，以及对每一个字段的引用就可以做到了： form method=post novalidate % csrf_token % % for field in form % div class=form-group label for=exampleInputEmail1 field.label /label field span style=color: red field.errors.0 /span /div % endfor % button type=submit class=btn btn-success确认提交/button/form 但是正是因为input框由 django 的 ModelForm 为我们自动生成，为其添加样式(例如 BootStrap)就变得比较困难。在 django 中存在解决这个问题的途径。 第一种：修改 ModelForm 类的 widget 属性 widget 属性决定了每一个字段通过 django 渲染出的 html 代码格式。例如要为username字段添加class=form-control的类名，那么我们就可以在定义 ModelForm 类时： class ExampleModelForm(models.ModelForm): class Meta: model = models.Administrator fields = [username] widgets = username: forms.CharField(attrs=class:form-control) 在字典中我们还可以添加其他键值关系，这样在前端渲染input时，就会带上我们所指定的class=form-control。同样的，在 widgets 字典中还可以指定多个字段自己的 widget 属性。 但是这样做会带来一个问题，例如我们对所有输入框都要应用 BootStrap 的样式，那么在 widgets 中逐个添加是否有些繁琐了呢？当然，我们也有办法解决这个问题。 第二种：重写init方法 在创造这个ExampleModelForm类时，其存在默认的__init__(self)方法。我们重写这个方法。 class BootStrapModelForm(forms.ModelForm):def **init**(self, *args, \\*\\*kwargs):super().**init**(*args, \\*\\*kwargs) # 循环每个字段为其插件进行设置for name, field in self.fields.items(): # 字段中有属性，则增加if field.widget.attrs:field.widget.attrs[class] = form-controlfield.widget.attrs[placeholder] = field.labelelse:field.widget.attrs = class: form-control, # 还可以添加其他的标签，例如 placeholderplaceholder: field.label 对上述代码做出一些解释。super().__init__(*args,**kwargs)是必须执行的，其初始化父类。然后，我们对存在的所有字段进行遍历，并对其中的field设置widget。其中，判断句if是为了防止覆盖原本的attrs属性。对于重写后的__init__(self)方法，我们可以单独将其作为一个父类，之后需要使用的所有 ModelForm 都改为继承此父类即可。 拼接 URL 在访问 url 时，许多网站采用 GET 方式传参，这种参数一般显式地拼接在 url 后，例如 https://127.0.0.1:8000/index/?page=4 在开发中，这样的参数可能不止一个，对于多个参数，在点击超链接时为了防止参数的损失，解决方式之一就是对超链接进行后端的拼接。django 自然也支持这个操作。例如我们需要对上述 url 拼接一个key=12的参数使得其能够携带两个参数，我们首先要获取已有的参数。在访问 url 时，request变量会携带所有与这次 url 访问有关的信息，因此，我们要从这里动手脚。当然，出于保护机制，django 不允许直接修改request的值，因此，我们需要拷贝一份。 query_dict = copy.deepcopy(request.GET) 说明一下上一行代码：request.GET携带了以 GET 方式传递的所有参数，其类型是一个字典。然后，我们要对query_dict添加键值关系，setlist()方法支持这种操作。例如我们来添加key=12。 query_dict.setlist(key, 12) 这样，新的键值关系就被我们添加完成了。此时query_dict的值应该是 query_dict = page: 4,key: 12 最后，我们拼接 url。 url = https://127.0.0.1:8000/index/?.format(query_dict.urlencode())print(url)# https://127.0.0.1:8000/index/?page=4key=12","tags":["django","python"],"categories":["程序设计","框架"]},{"title":"快速生成requirements.txt","path":"/posts/11/","content":"前言 众所周知，Python的运行效率是不高的。但为什么Python还是很广泛地被使用呢？那当然是成熟的第三方库的加持！可以说Python的第三方库只有你想不到，没有他做不到的。因此，对于一个自己的或者是clone来的项目，下载依赖包就显得非常之重要。 快速生成requirement.txt 首先我们用包管理工具pip安装生成requirements.txt的插件。 然后一行简单的命令就可以快速生成requirements.txt啦！ 比起传统的pip freeze requirement.txt这句命令，上面可以做到虚拟环境之间相互隔离！也就是说，生成的requirements.txt只会包含当前项目用到的包，也很合常理对吧？ 偶尔水一水也不会有事的吧？","tags":["Python"],"categories":["程序设计","语言"]},{"title":"django学习笔记(3)：models数据类型处理","path":"/posts/10/","content":"如何在 django 中处理不同的数据类型？ 前言 django 通过继承models类来完成数据库表的创建，其中牵涉了很多数据类型和相关的知识点，这里把最近碰到的记录一下。 Django 中数据类型的处理 首先来看一下最近一个练手项目(用户管理系统)中基础的部门表和用户表的定义。 from django.db import models# 员工管理系统class Department(models.Model): 这是部门的表：id, title title = models.CharField(verbose_name=标题, max_length=32)class UserInfo(models.Model): 员工表 name = models.CharField(verbose_name=姓名, max_length=16) password = models.CharField(verbose_name=密码, max_length=64) age = models.IntegerField(verbose_name=年龄) account = models.DecimalField(verbose_name=账户余额, max_digits=10, decimal_places=2, default=0) create_time = models.DateTimeField(verbose_name=入职时间) depart = models.ForeignKey(to=Department, to_field=id, on_delete=models.CASCADE) # 性别选项 gender_choices = ( (1, 男), (2, 女), ) gender = models.SmallIntegerField(verbose_name=性别, choices=gender_choices) 针对上面出现的类型，这里做一些相应地解释。 CharField CharField是基础的字符串类型，上述案例中，verbose_name=参数在许多函数中都出现了，实际上，这个参数主要是便于开发者自己了解每一个字段代表什么含义，由于我们是 Django 开发，因此我们使用注释的方案也可以，具体看个人喜好。对于 CharField 来说，max_length=是必要的，因为在创建 MySQL 表时，我们需要指定每一个varchar的字节数。 DecimalField 是 Python 中十进制浮点数的实例。上述例子中含有两个参数，max_digits=表示数字位数，这是同时包含整数部分和小数部分的位数。decimal_places=表示小数位数。default=用于在使用UserInfo.objects.create()时没有指定account参数值的时候的默认值。 DateTimeField DateTimeField是专门存储时间的字段类型，格式为Y-m-d H:m:s。当我们要输出这个值时，我们通常要先对其进行格式化。我们使用strftime(format)来达到这个目的。format 的格式包含以下多种选择。 %y 两位数的年份表示（00-99）%Y 四位数的年份表示（000-9999）%m 月份（01-12）%d 月内中的一天（0-31）%H 24小时制小时数（0-23）%I 12小时制小时数（01-12）%M 分钟数（00=59）%S 秒（00-59）%a 本地简化星期名称%A 本地完整星期名称%b 本地简化的月份名称%B 本地完整的月份名称%c 本地相应的日期表示和时间表示%j 年内的一天（001-366）%p 本地A.M.或P.M.的等价符%U 一年中的星期数（00-53）星期天为星期的开始%w 星期（0-6），星期天为星期的开始%W 一年中的星期数（00-53）星期一为星期的开始%x 本地相应的日期表示%X 本地相应的时间表示%Z 当前时区的名称%% %号本身 当然，我们最常用的还是 time.strftime(%Y-%m-%d %H:%m:%s) # 精确到秒的时间记录time.strftime(%Y-%m-%d) # 精确到日期的时间记录 在 Django 模板语法中，一般是不允许出现括号的。在前端页面，我们需要改写成 span time|date:Y-m-d /span 在 Pycharm 中按住Ctrl查看上述案例中date的源码，可以发现其也是一个函数，只不过使用了特殊的|符号表示而已。 ForeignKey ForeignKey表示的是外键，也就是将表与表之间建立联系的一种方式。在上述案例中，由于我们需要知晓员工的所属部门，因此我们使用外键将depart字段与Department中的id字段相关联。在 Django 自动生成表的时候，depart字段会被命名成depart_id。使用ForeignKey的时候，我们需要指定参数to=和to_field=，前者指定与哪张表关联，后者指定关联的字段名。当然了，由于关联的原因，我们还需要指定on_delete=，这个参数指定当Department表中的数据删除时，UserInfo中对应这些数据的记录将要如何操作。models.CASCADE表示级联删除，即删除所有与被删除数据相关联的记录；还可以选择models.SET_NULL，这样所有关联数据的该字段将会被置空。但这有一个前提，你需要在参数列表指定该字段可以为空，即 department = models.ForeignKey(to=Department, to_field=id, null=True, blank=True, on_delete=models.SET_NULL) 在读取数据中，我们需要先获取UserInfo的记录，再通过外链访问Department，即 obj = models.UserInfo.objects.fileter(筛选条件).first() # 获取满足筛选条件的第一个对象print(obj.depart_id) # 访问obj.depart_id，我们得到的是部门idtitle = models.Department.objects.filter(id=obj.depart_id).first().title # 再次筛选，取出title字段才是我们要的部门名称title = models.Department.objects.filter(id=models.UserInfo.objects.filter(筛选条件).first().depart_id).first().title# 合并上述语句我们得到非常之长的一句数据库查询语句 显然，这句语句太长了，Django 提供了另一种通过外键查询另一张表的方式，在上述例子中 obj = models.UserInfo.objects.fileter(筛选条件).first() # 获取满足筛选条件的第一个对象print(obj.depart.title) # 这时直接输出了部门名字 在这种书写方式下，obj.depart直接返回根据depart_id查询到的第一个object。由于我们这个案例中 ID 值唯一，于是直接访问其.title即可。 于是在前端页面，我们可以通过如下的模板语法访问每一个人对应的部门的名称： tbody % for obj in userinfo_list % tr td obj.name /td td obj.depart.title /td /tr % endfor %/tbody SmallIntegerField 该数据类型常应用于固定的枚举型，例如上例中的性别。在绝大多数情况下，性别是不会继续添加的，因此我们可以用元组的嵌套来指定这种对应关系： gender_choices=( (1, 男), (2, 女)) 相比于存储汉字，在数据库中存储短整型占用更少的存储空间。这种情况下，你需要为SmallIntegerField指定参数choices=。这个参数接受一个嵌套元组用来指定对应关系。 当然，这会带来一个问题，我们访问obj.gender时，会输出整型而非我们想要的汉字“男”或“女”，同样的，Django 提供了一个函数： obj.get_gender_display() # 这个函数名称会随着你对字段名命名的不同而变化# 命名规则obj.get_字段名称_display() 在前端页面，你可以使用模板语法来完成这个功能： obj.get_gender_display 需要注意的是：你依然不需要在函数末尾添加括号。 Django 的 html 模板 这部分不是本文的重点，但也是Django开发中十分重要的一部分，其可以大大增加代码复用率。因此也一并写在这里。 很多时候，许多 HTML 文件都具备一部分的相同结构，例如，所有页面都有页面顶部的导航栏(navigation bar)，都需要引入相同的 css 和 js 等文件。Django 提供模板页面来解决这个问题。我们只需要在模板文件中需要被插入的结构加入： !DOCTYPE htmlhtml !--省略以上html内容-- % block 板块名称 % % endblock % !--省略以下html内容--/html 然后再需要使用的页面引入该模板即可，如果模板名称为layout.html，那么就可以写成这样： % extends layout.html % % block 模块名称 %!--这里是你的html--% endblock % 渲染该页面时，Django 会自动将其与模板layout.html拼接。一个模板中可以有多个这样的结构，一个 HTML 文件中也可以由多个这样的结构组成。 后记 这篇文章字不多，但干货占比也挺高的。赶紧写出来也是方便我后续复习和查询使用。~~所以就浅浅地日更了一下。~~那这篇文章就到此结束吧！该休息咯。","tags":["django","python"],"categories":["程序设计","框架"]},{"title":"django学习笔记(2)：操作MySQL数据库","path":"/posts/9/","content":"使用 django 操作 mysql 数据库。 前言 数据库是 web 应用中很重要的组成部分之一。Django 框架自带了 sqlite3 数据库，然而在使用的广泛程度上，MySQL 的应用场景更加多。本篇主要解释如何将数据库换成 MySQL，以及一些基本用法。 更换默认数据库为 MySQL 创建数据库 由于 django 的 orm 只能完成对于表的操作，因此数据库的创建需要我们自行完成，这里以本地 MySQL 数据库为例。在 MySQL 终端输入 完成数据库的创建。然后运行 use db_name ，若提示为 empty set（空的数据库），则创建成功。 安装第三方依赖 首先我们需要安装第三方包 pymysql （你也可以使用mysqlclient），这个第三方包能够帮助 Django 完成对 MySQL 数据库的增删改查操作， 如果安装缓慢，可以参考本系列的第一篇文章，将安装源换成国内镜像站。 更改项目配置文件 在项目目录下找到setting.py，找到DATABASES，这里默认是 DATABASES = default: ENGINE: django.db.backends.sqlite3,NAME: BASE_DIR / db.sqlite3, 其中， ENGINE 指明了数据库类型， NAME 指明了数据库名称。默认情况下，Django 使用内部集成的 sqlite3.我们修改之， DATABASES = default: ENGINE: django.db.backends.mysql,NAME: webapp, # 数据库名字USER: root,PASSWORD: 你的密码,HOST: 127.0.0.1, # MySQL 在哪个 ipPORT: 3306, # 端口号 其中，HOST是主机 ip，这里使用的是本地，因此是127.0.0.1，PORT是端口号，本地 MySQL 的端口号是3306。然后，你需要在项目的_init_.py中添加： import pymysqlpymysql.install_as_MySQLdb() 使用 Django 操作 MySQL 的表 创建表 表的操作都可以用 python 语法完成，其中 orm 会将其翻译成 SQL 语句，对于我们来说，无需自己再写 SQL 语句了。 在已注册的应用下的models.py中新建类，例如我们要创建一个用户信息的表，那么我们可以写成 from django.db import modelsclass UserInfo(models.Model):name = models.CharField(max_length=32)password = models.CharField(max_length=64)age = models.IntegerField(default=0) 然后，我们在终端运行 这时，Django 自动为我们创建了表，其相当于 create table app01_userinfo(id bigint auto_increment primary key,name varchar(32),password varchar(64),age int) 在 MySQL 终端输入 终端输出 mysql show tables;+----------------------------+| Tables_in_webapp |+----------------------------+| app01_userinfo || auth_group || auth_group_permissions || auth_permission || auth_user || auth_user_groups || auth_user_user_permissions || django_admin_log || django_content_type || django_migrations || django_session |+----------------------------+11 rows in set (0.00 sec) 这表明，app01_userinfo的表已经被创建。当然，这里其他的表示 Django 内部的其他类，我们这里无需在意。接下来我们检查字段。MySQL 终端输入 观察到输出 mysql desc app01_userinfo;+----------+-------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+----------------+| id | bigint | NO | PRI | NULL | auto_increment || name | varchar(32) | NO | | NULL | || password | varchar(64) | NO | | NULL | || age | int | NO | | NULL | |+----------+-------------+------+-----+---------+----------------+4 rows in set (0.00 sec) 其中，name，password和age都是我们所定义的字段，id是 Django 自动创建的字段。 修改表 当然，我们也免不了修改表的字段数，例如，我们不需要age这一个字段了，我们只需要在models.py下删除之。 from django.db import modelsclass UserInfo(models.Model):name = models.CharField(max_length=32)password = models.CharField(max_length=64)- age = models.IntegerField(default=0) 然后重新在终端执行makemigrations和migrate二连，我们就可以观察到这一字段消失了。 有时候，我们也会为表中新增字段，例如： from django.db import modelsclass UserInfo(models.Model):name = models.CharField(max_length=32)password = models.CharField(max_length=64)age = models.IntegerField(default=0)- sex = models.CharField(max_length=4) 执行数据迁移二连，我们会发现控制台有警报。 控制台警报 这是因为，当我们添加字段时，如果表中有数据，那么这些数据的新字段的值我们就不得而知。因此，会产生上述的告警。控制台给了我们两种解决方式： 为已有的数据分配初始值来填补这些空缺； 在models.py中声明初始值。 对于选择 1，我们可以将已有的数据的该字段的值赋值成为我们指定的值，这里不多说了。对于选择 2，则需要为该字段指定默认值，那么上述语句可以被重写成 class UserInfo(models.Model):name = models.CharField(max_length=32)password = models.CharField(max_length=64)age = models.IntegerField(default=0)- sex = models.CharField(max_length=4)* sex = models.CharField(max_length=4, default=male) 于是，控制台告警消失，并且之前所有已存在的数据的新字段都被赋值为初始值。当然了，你也可以声明该字段允许为空，例如： class UserInfo(models.Model):name = models.CharField(max_length=32)password = models.CharField(max_length=64)age = models.IntegerField(default=0)- sex = models.CharField(max_length=4, default=male)* sex = models.CharField(max_length=4,blank=True,null=True) 这样也是可以的。 使用 Django 操作 MySQL 中的数据 我们依然可以用 python 语句来操作 MySQL 中的数据。 创建数据 创建数据的语法是： 类名.objects.create(参数列表) 例如我们需要在app01_userinfo中插入一段记录，以下就是一个例子： UserInfo.objects.create(name=Felix, password=123, age=19) 这句 python 会被 orm 翻译成 SQL 语句： insert into app01_userinfo(name, password, age)value(Felix, 123, 19) 删除数据 删除数据的语法是： 类名.objects.filter(筛选条件).delete() 如果你要清空数据，那么可以写成 类名.objects.all().delete() 当然，过滤函数还有许多写法，这里只展示了filter()和all()。 查找数据 查找数据的语法是 类名.objects.filter(筛选条件) 函数的返回值是一个QuerySet类型，在 python 中，其可以被理解成结构体对象的列表，例如 [UserInfo: UserInfo object (1), UserInfo: UserInfo object (2), UserInfo: UserInfo object (3)] 如果我们要读取其内部值，就可以用简单的 python 语法实现，这里举个例子： user_info_list = UserInfo.objects.all()for obj in user_info_list:print(obj.id, obj.name, obj.password, obj.age) 当然，如果我们明确知道表中只有一行数据，那么我们可以避免使用循环，直接用 obj = UserInfo.objects.all().first() 获取对象即可。 更新数据 更新数据，首先要找到需要更新的记录，因此，前一部分与查找是很相似的。update()函数完成后续的更新操作，例如： UserInfo.objects.filter(id=2).update(password = 999) 则被筛选出的记录的password字段都会被更新成999。 后记 有了与数据库的联动操作，我们已经可以写一些基础的业务逻辑了。当然，Django 对于数据库的操作远不止这些。","tags":["django","python"],"categories":["程序设计","框架"]},{"title":"django学习笔记(1)：Django的安装与准备","path":"/posts/8/","content":"开一个新坑，django 开发。 Django 介绍 Django 是一个开放源代码的 Web 应用框架，由 Python 写成。利用 Django 和相关的 html 和 CSS 知识，我们可以轻松构建出一个简单的网站。本文主要介绍使用 Django 的一些准备工作。 安装 Django 首先，你需要 Python 环境。这里以 Python3 环境为例。安装有两种方式：命令行安装和使用开发软件 Pycharm。 使用命令行Pycharm中使用 这里以 Linux 操作系统为例。首先打开命令行窗口，建立虚拟环境。 而后激活此虚拟环境。 如果想要停止此虚拟环境，你可以使用deactivate来关闭之。然后我们来下载 Django。 如果下载速度很慢，你可以尝试更换成国内镜像源。例如pip install Django -i https://pypi.tuna.tsinghua.edu.cn/simple清华：https://pypi.tuna.tsinghua.edu.cn/simple阿里云：http://mirrors.aliyun.com/pypi/simple/中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/华中理工大学：http://pypi.hustunique.com/山东理工大学：http://pypi.sdutlinux.org/豆瓣：http://pypi.douban.com/simple/Pycharm 中的使用相对而言简单许多。在项目文件下新建项目，而后在文件-设置-项目-Python解释器中安装 Django 即可。 开始使用 Django 新建 Django 项目 下载完 Django 库后，我们需要在我们的项目文件夹中新建一个 Django 项目，这将告诉 Django，这不是一个纯 Python 项目。首先我们在 Pycharm 的终端或者命令行窗口运行以下指令： django-admin startproject projectname . 其中，projectname是项目名称。 如果你使用的是PycharmProfessional Edition，那么你可以直接在创建项目之初就创建Django项目，而无需上述的多步操作。但需要注意，在项目的setting.py中TEMPLATES中第一个字典的键DIRS存在[os.path.join(BASE_DIR, templates)]，它将影响静态文件查找位置，最好删去。 注意，上述的命令语句千万不要忘记末尾的.。遗漏了这个句点将在后续项目部署上需要额外的复杂操作。 最后运行python manage.py runserver，检查 Django 是否能正确运行。若可以，则初步配置成功。 Django 项目中的文件结构 projectname├─manage.py 【项目管理、启动项目、创建应用、数据管理】【无需更改】│└─projectname ├─__init__.py ├─settings.py 【项目配置文件】【例如注册应用、链接数据库】 ├─urls.py 【url和函数对应关系】【主要编写的部分】 ├─asgi.py 【接收网络请求】【无需更改】 └─vsgi.py 【接收网络请求】【无需更改】 新建应用 根据项目的业务逻辑，我们将其分为多个应用来分开管理。我们先新建第一个应用，在终端输入命令 python manage.py startapp appname 于是我们得到这样的目录。 projectname├─manage.py 【项目管理、启动项目、创建应用、数据管理】【无需更改】│├─appname| ├─__init__.py| ├─admin.py 【后台管理界面】| ├─apps.py 【启动类】| ├─models.py 【在数据库中创建对应表】| ├─tests.py 【测试类】| ├─views.py 【函数】| └─migrations 【数据库迁移记录】| └─__init__.py|└─projectname ├─__init__.py ├─settings.py 【项目配置文件】【例如注册应用、链接数据库】 ├─urls.py 【url和函数对应关系】【主要编写的部分】 ├─asgi.py 【接收网络请求】【无需更改】 └─vsgi.py 【接收网络请求】【无需更改】 新建应用后，我们需要对其注册。我们找到应用下的apps.py，找到其启动类类名，以下是一个例子。 # filename: apps.pyfrom django.apps import AppConfigclass App01Config(AppConfig): default_auto_field = django.db.models.BigAutoField name = app01 于是我们修改settings.py中的内容： # filename: settings.py# 省略INSTALLED_APPS = [ # 省略 appname.apps.APP01Config,]#省略 于是，新的应用已经注册完毕，我们可以在该应用上开发了。","tags":["django","python"],"categories":["程序设计","框架"]},{"title":"《Hollow Knight(空洞骑士)》简评","path":"/posts/7/","content":"这次打算写点不一样的，就来浅浅聊一下最近走完主线剧情的《Hollow Knight(空洞骑士)》吧。 前言 《空洞骑士》这款游戏其实一直存在于笔者的愿望单里，但是有好长一段时间也是仅仅存在于愿望单里而已。后来在室友的强烈推荐、并且Steam促销的双重驱动下，还是下载了这款游戏。6月份期末周一结束，便下定决心体验这款游戏。玩了40h也勉强算是通关了主线剧情。这里就简要地说一说自己想说的吧。 关于游戏 谈谈设计 BOSS设计 如果要简单地概括《空洞骑士》的游戏形式，我想“平台跳跃游戏”的标签就足够让大家知道其游玩形式了。此外，这款平台跳跃游戏还包含了“魂类游戏的要素”，简而言之，就是不低的死亡成本和难度较高的BOSS设计。其实玩家们都会知道一个说法：三螳螂是多少新手的噩梦。 新手劝退关：三螳螂之战 但其实，具有一定难度的BOSS设计也在很大程度上增加了游戏的可玩性。与其使用炫酷的特效和画面来告诉一个玩家你将面对的敌人有多么强大，倒不如直接让玩家体会被BOSS击败的无力感。 当然了，这也为游戏制作者带来了不少的挑战：难度如何把控？如何让每一个不同的BOSS都有其特色？这其实是不容易把握的。笔者曾经体验过《Sekiro: Shadows Die Twice(只狼：影逝二度)》这款游戏。虽然这部作品依然非常出色，但其实有部分BOSS（或者严谨的说，精英怪）的设计是有些重复的（比如蚺蛇重藏和牛饮德次郎，但也有人认为他们其实是一个人，这里就不展开讨论了）。但不得不说，《空洞骑士》的BOSS设计并不会让人觉得厌烦，面对新的BOSS，总有新的打法可以尝试。 下砸老师：粪虫防御者 黑冲老师：叛徒领主 操作设计 在玩家操作上，《空洞骑士》没有采用大量的按键、或者是游戏内技能选择来控制技能释放，所有的技能都可以通过少量键位完成释放。单纯攻击键，直接释放是平砍、与“上”键组合是上砍；与“下”组合是下劈(非常有技术含量的操作)；长按攻击键蓄力，通过独自释放、与上键组合、与下键组合完成三种不同的剑技；跳跃键按住时长控制跳跃幅度；长按施法是恢复等等。键位虽少，但是用好谈何容易。真正熟练之后，你会发现，看似不可能的道路可以通过下劈、二段跳、冲刺的组合轻松越过，竞技场的可以足不沾地与对手们进行空战等等。其实主角并没有飞行的能力，但又何尝不像在飞行。 竞技场空战：下劈、二段跳、螳螂抓钩的奇妙组合 谈谈剧情 故事发生在一个称为“圣巢”的底下虫子王国里。上古时期，圣巢被虚空之力所占领。在这里，虚空才是一切的主宰。后来，名为幅光的神驻留在此地，利用自身的光芒将虚空的黑暗逐步逼退，最后将其困于深渊之中。自此，幅光便是这个王国的唯一领袖，圣巢也在他的带领下逐渐繁荣昌盛。 幅光 但后来，一只名为沃姆的虫子路过此地，有了驻足此地的想法。沃姆与幅光对于圣巢的统治有着根本的不一致观点。幅光，主张思想上的统一，反对繁衍；而沃姆，却强调虫子的多样性。于是，沃姆和幅光的大战一触即发。但是，沃姆不敌幅光，在大战中败下阵来，就此死去。 但需要注意的是，在《空洞骑士》的世界观中，死亡并非消逝。所有的死亡，都会留下踪迹。沃姆也是这样。白王，就是沃姆死后的化身。 白王的遗迹 幅光自然无法接受自己被白王击败的结局，于是，幅光利用梦境释放瘟疫感染圣巢内的虫子。在瘟疫的感染下，虫子们完全丧失了自主意识，只能进行基本且简单的思考。繁荣的圣巢，一刹那间成了死寂的废墟。在这里，只有无意识的虫子和瘟疫。 但白王自然无法容忍这样事情的发生。他发现，圣巢内的蜂巢和螳螂村完全不受瘟疫感染。究其原因，是因为他们都有坚定的意志：蜂巢有自己的领袖信仰；而螳螂村，崇尚武力，他们的存在就是追求更高的荣耀。因此，他们不受瘟疫的感染。换句话说，只有真正的无意识或者坚定意志，才能免于幅光散播的瘟疫的感染。于是，容器就诞生了。 击败BOSS后鞠躬表示敬意 容器们的本体诞生于虚空，白色的头颅是容纳他们的虚空的自我的容器。他们源自虚空，所以完全没有个人的意志。他们的任务，就是对抗幅光的瘟疫，并永久地封印幅光，将圣巢变回原来的样子。但是，容器们并非都是可用的。容器必须没有自我意识，并且必须具有强大的能力。迈出深渊，就成为了容器们的第一道考验。深渊里，满是破碎的容器躯壳，他们都是白王失败的作品。但，有一个容器，成功通过了考验，迈出了深渊，完成了修炼。而他，就是纯粹容器，也叫空洞骑士 。 没有可以思考的心智 没有可以屈从的意志 没有为苦难而哭泣的声音 生于神与虚空之手 你必封印在众人梦中散布瘟疫的障目之光 你是容器 你是空洞骑士 空洞骑士承载着白王的愿望，将幅光封印在自己体内，从而阻止瘟疫的扩散。事实证明，他也成功了。瘟疫在圣巢渐渐散去，满是僵尸的圣巢，又渐渐开始恢复往日的荣光。为了保证彻底的封印，白王号召了三位守梦者来加固封印。作为代价，三位守梦者会陷入永久地沉睡。为了纪念他们，白王在泪城的不同地方建立了纪念碑。 纪念空洞骑士 守梦人纪念碑 但是，令白王没想到的是，纯粹容器并不纯粹。苦痛之路的尽头告诉我们，空洞骑士与白王的朝夕相处已经使得空洞骑士对白王产生了亲情。同时，空洞骑士在深渊的回头，也表示他对兄弟产生了情感。不纯粹的容器，势必要被幅光所感染。对于幅光而言，存在于梦境之中的他如果不被同族所记住，那他就与死亡无异。幅光渐渐感染空洞骑士，挣脱了束缚，又重新向圣巢散播了瘟疫。而这次，设法从深渊逃离的小骑士感受到了同类的召唤，回到了圣巢。 小骑士在圣巢的探索中，一步步揭开王国的过去，直面自己空虚的内在，背负起重建圣巢的责任。 当然，游戏也有多个结局。其中一个便是小骑士击倒先辈(空洞骑士)，进入梦境，直面幅光。这是小骑士第二次庄严拔刀，也是最后一次。击败幅光后，小骑士会舍弃自己的容器，将自己的虚空之躯暴露在外，在前辈的配合之下击杀幅光。 击败幅光 从此，瘟疫散去，但圣巢也不如从前。封印幅光的黑巢中剩下的，只有小骑士残破的外壳。而小骑士完成了自己的实名，重新回到深渊的虚空之中。 整个游戏其实蛮黑暗的。不论是结束后的音乐画面，还是黑暗战胜光芒的主线剧情(当然这里的光芒才是反派)，又或是小骑士和其他大部分NPC的结局，都让人觉得遗憾。在这个游戏中，满是衰落王国的萧瑟和主角的自我牺牲。游戏的最后，白宫依然只存在于守卫的梦境之中，鹿角站铃铛也不会再热闹起来，深渊的一切也回归虚空，蓝湖边只剩下一把骨钉… 后记 其实我的文笔也蛮烂的，也第一次整理剧情和时间线。希望大家可以多提提意见什么的。写这篇文章也主要是记录一点自己的感受，毕竟到现在想起这段故事还会觉得可惜和遗憾。但是这个游戏真的太优秀了！我真的强推。最后的最后还想和大家分享几个我喜欢的BGM！绝对入股不亏！","tags":["游戏","空洞骑士"],"categories":["娱乐","游戏简评"]},{"title":"6月24日","path":"/posts/6/","content":"随便写写。 写点东西，或许以后会放出来 上个学期，大概是三月份的时候，无比期待着转专业。当时对于转专业的热情似乎有些太上头，以至于有一段时间满脑子都是转专业，甚至连上课都会思绪飘走。到了四月中旬，知道不能在平台内转专业后，便想着要不要去安泰。说实话，我当时发现自己下意识有了这个想法以后，就觉得自己可能不是那么想学某一专业，我可能更加是在找寻一种逃离。当时和另外一个朋友说了这个想法，确信了自己似乎在转专业这件事上走错了路，目的似乎已经改变了。于是，经过内心的斗争，还是放弃了四月份的自主转专业。（其实说实在话，也有一部分原因是害怕自己下半学期太摆，导致学积分疯狂后退，便想着赶紧趁着优势润了） 其实说实话，我很喜欢生医工的氛围。疫情期间更让我看清楚生医工拥有大院所比拟不了的人文关怀。这点其实很显然，我想不管是谁都能感觉出来。因为这个其实也有点动摇到我的转专业决心了，虽然不是主要原因。但我想过，如果我在大院，可能并不会有老师那么关注我，也不会在被转运的时候有学院领导来慰问我，也不会有班主任打电话了解学习状况，更不会有刚步入学生会就能参加很多重要活动的核心策划。我得到的许多我认为很重要的东西，其实并不是我能力多么强，纯粹是因为学院规模小，给予了我更多的机会而已。我害怕转专业后，来到陌生的环境，可能再也得不到生医工给我的归属感。 最近可以说是我转专业热情消退的最严重的一段时间了。我退出了夏季学期选的NIS的课程，也对当初满怀希望报名的PRP丧失信心。因为我无法在这两门课中找到充足的动力去学习它们。原因或许只是因为我对它们不感兴趣，但也未必那么简单。可能是经历了一学期的神经紧绷，拼命追求一个不错的绩点后的精疲力竭；也能是PRP的能力要求对我来说确实为时尚早；也可能是NIS的那门课的设计确实让人难以产生兴趣。如果是这两种，那还好，至少不是我对信安专业知识的麻木，但如果是第一种，那是否意味着，**在体验信安的学习过后，我已经提不起兴趣了呢？**这种无法将问题正确归因的状态导致我这两天都无所事事。于是，加上三四月份的内心挣扎，我会质问我自己：我真的想转专业吗？还是纯粹是一种突发的错觉？ 但是时间不等人。大二的上学期，我需要同时决定转不转专业、是否辅修；如果是，如何安排这两件事？我需要利用时间搜集资源和信息，但是暑假，我还有其他任务在身，并且，好好地休息。这太难以决定了。我发现上大学后，需要自己决定并且承受后果的事情太多了，而且这些事情往往只有一次机会，错过就不再来。如果用两个词形容我现在的处境，就是犹豫和纠结。 最近把关于我页面的内容也做了一些修改，是因为我现在也不了解自己的想法。等到什么时候想明白了，再好好写吧。","tags":["碎碎念"],"categories":["杂谈"]},{"title":"Python学习笔记：列表和字典","path":"/posts/5/","content":"作者序 学习一门编程语言，语法是最基础的。但是学习语法往往不是那么困难，因此，写一篇语法笔记似乎显得不是那么有必要。事实正如此，对于Python中的循环、判断等语句，我并没有整理的意图，因为我觉得太过多余，即使可以玩的很花。但是对于列表和字典这一章内容，其重要之处或许不在于其语法有多难，而是其体现了一些数据结构的思想。在C++中，线性表与这里的列表；查找表与这里的字典，都有着一些奇妙的联系。而因为Python很好的隐藏了一些底层实现，若不注意细节而使用这些内置函数和方法，是极有可能出错的。因此，本文将这些内容记录下来，既可以作为初学者的参考，又可以作为我的笔记以待后续查阅。 正文 列表 什么是列表 Python中的列表是一系列特定元素按特定顺序构成的集合，这和C++中数组十分相似。对于列表，我们通常用[]来声明一个变量储存一个列表，例如 bicycles = [trek, cannondale, redline, specialized] #初始化结束的列表empty = [] #声明一个空列表 访问列表元素 和C++相类似的，Python支持根据元素下标来访问元素。例如对于上面的bicycles列表，我们可以用bicycles[0]来访问元素'trek'。当然了，Python支持使用负数索引来访问列表元素，例如访问上面列表中的'specialized'，我们除了使用bicycles[3]，还可以使用bicycles[-1]来访问这个元素。对于长度未知的列表，我们可以用这个方式来访问末尾的几个元素。 列表元素的修改、添加和删除 既然我们说列表是一种线性表，那么其需要能够支持线性表的基本操作。Python内置了丰富的函数和方法支持我们做到这些操作，下面逐一介绍之。 修改元素 对于修改元素，我们可以直接指定列表元素下标修改之，例如 bicycles[0] = ducati 这样，我们就将列表中原本的'trek'元素修改成了我们指定的'ducati'元素。 插入元素 对于插入元素，Python提供了两种方法，分别是insert()和append()。对于前者支持在指定位置插入元素，而后者是将元素插入到列表尾，例如下面代码： bicycles = [cannondale, redline, specialized]print(bicycles)bicycles.append(ducati)print(bicycles)bicycles.insert(2, trek)print(bicycles) 则对应的程序输出为 [cannondale, redline, specialized][cannondale, redline, specialized, ducati][cannondale, redline, trek, specialized, ducati] 删除元素 对于删除元素，一般有三种方法：del语句，pop()方法和remove()方法。 对于del语句，你只需要指定删除的元素即可，例如 del bicycles[0] 就是删除bicycles中的第一个元素。 对于pop()方法，一般由两种使用方式：无参数和指定元素下标。对于无参数的pop()方法，会删除当前列表中的最后一个元素。这种模式下的pop()方法和之前提到过的append()方法可以天然的实现一个栈。或者，你也可以指定pop()的参数，例如bicycles.pop(1)，则其中的'redline'元素就会被移出列表。pop()方法具有返回值，返回值是被删除的元素。 对于remove()方法，是查找列表中第一个和指定参数相同的值，将其删去。注意，由于只删除第一个查找到的值，因而如果我们要将指定参数的值都删去，需要使用循环，例如 languages = [cpp, python, c, go, python, html]while python in languages: languages.remove(python)print(languages) 这种方式下，可以将列表中的所有指定元素都删除。 组织列表 除了基本的增删改查，我们对于列表还需要一些操作，这种操作不更改列表元素值，但是会更改元素之间的顺序。很便于使用的，Python依然为我们内置了强大的函数和方法来实现这些功能。 函数名 解释 用法示例 sort()方法 对列表永久非减（或非增）排列 bicycles.sort()或者bicycles.sort(reverse = True) sorted()函数 对列表临时非减（或非增）排列 sorted(bicycles)或者sorted(bicycles, reverse = True) reverse()方法 列表逆置 bicycles.reverse() len()函数 列表求长 len(bicycles) example[:] 列表切片 bicycles[0:3] 注意，复制列表时，注意一下两种方式的区别： foods1 = [apple, pizza, hamburger]foods1 = foods2 #这种复制是错误的foods1 = foods2[:] #利用列表切片的方式复制 第一种复制的结果是使得foods1和foods2指向了同一个列表，使得在更改foods1的列表元素时，foods2也会一同改变。而后者是两个互不干涉的、独立的列表。 字典 Python中，字典是若干组键-值对的集合，其一般形式如下： target = color: blue, points: 5, speed: fast, 通过构建这样的键值对，我们可以通过键来访问其对应的值，有点类似于自定义下标的数组。上面示例中的target，就是我们说的字典。 访问字典的值 如同上面所说，我们完全可以把其当成数组来用。如果我们要知道target的color信息，我们可以通过下面的代码输出它： print(target[color]) 这时控制台输出blue。 添加或修改键值对 这两点放在一起讲的原因是，两者的语法是相同的。请读者参见以下代码： target[color] = red #1target[x_position] = 4 #2 对于第一条语句，首先在字典target中寻找关键字'color'，由于找到的缘故，将其对应的值覆写为'red'。对于第二条语句，由于无法在字典中查询到'x_position'的任何记录，因而新建了一对键值关系，并将其插入了字典中。 删除键值对 同样的，del语句给我们提供了删除键值对的方法。如果我们需要删除有关位置的信息，我们只需要del target['x_position']语句即可。 遍历键值对 如果我们想遍历键值对，可以使用的最简单的语句是： for key, value in target.items(): print(key + + value) 上述语句将字典中的每一个键值对，都分别把键、值赋值给了key和value。当然了，这时的输出顺序未必按照我们定义的一般按顺序输出，原因是字典只保证键值对的一一对应关系，而不在意互相之间的顺序问题。因此，要按照顺序遍历字典，我们需要使用其他的方式， 对于字典，Python内置了两种方法：keys()方法和values()方法。两者返回的都是列表，前者是键组成的列表，后者是值组成的列表。相信到这里，你已经有思路如果按照顺序遍历字典了，这里给出一种方式： favorite_language = jen: python, sarah: c, edward: ruby, phli: python,for person in sorted(favorite_language.keys()): print(person.title() + s favorite language is + favorite_language[person].title() + .) 上面的程序输出结果是 Edwards favorite language is Ruby.Jens favorite language is Python.Phlis favorite language is Python.Sarahs favorite language is C. 由此，我们做到了按照我们所想遍历字典。 尾声 读者可以看到，Python中的列表和字典，其实已经包含了很多数据结构的东西，并且都给我们准备了不错的函数和方法。巧妙的是，这两个结构都可以自我嵌套，甚至互相嵌套，功能可以说已经非常强大了。因此，就像学习C++时刚接触到的函数一样，列表和字典也是水很深的内容之一。随着我的了解不断深入，我也会不断更新这篇文章。基础部分，就到此为止了。","tags":["Python"],"categories":["程序设计","语言"]},{"title":"数据结构试题分析","path":"/posts/4/","content":"作者序 题目均来自于往年试卷，给出的代码都能够编译通过。 例题一：哈希表的使用 题面： 假设线性表采用顺序存储结构，试实现函数int DelRepeat()，用以删除所有重复元素，并返回删除元素的个数。要求算法的时间复杂度为O(n)O(n)O(n)。线性表结构定义如下： class seqList private: int* data;//保存的元素数组 int currentLength;//元素个数 int noData;//数据中不存在的元素 public: int DelRepeat() //add your code here ; 代码实现如下，注意：测试代码未给出，请读者自行构造。 class seqList private: int* data;//保存的元素数组 int currentLength;//元素个数 int noData;//数据中不存在的元素 public: seqList(int n)//构造函数 currentLength=n;//元素个数 data=new int[n]; coutinput data:endl; for(int i=0;in;++i)//获取元素值 cindata[i]; void display()//展示数组元素 coutthe data are:endl; for(int i=0;icurrentLength;++i) coutdata[i]\\t; coutendl; int delRepeat(int n)//删除重复元素 noData=n;//标记输入数据中不存在的元素 bool* status=new bool[currentLength]; for(int i=0;icurrentLength;++i)//创建判断元素，为真则该位置的数字出现过 status[i]=false; int* hashtable=new int[2*currentLength];//创建哈希表 for(int i=0;i2*currentLength;++i)//哈希表初始化 hashtable[i]=noData; for(int i=0;icurrentLength;++i) int pos=data[i]%(2*currentLength);//获得哈希值 while(hashtable[pos]!=noDatahashtable[pos]!=data[i]) (++pos)%(2*currentLength);//定位到第一个可以插入的位置 if(hashtable[pos]==data[i]) status[i]=true;//如果有该元素，标记为待删除元素 else hashtable[pos]=data[i];//没有该元素，插入该元素 //end for int i=0,j=0; int newLength=0; int oldLength=currentLength; int* tmp=new int[currentLength];//装载没被删去的元素 for(int i=0;icurrentLength;++i) if(!status[i])//如果判断数组对应位置为假，保留该数字 tmp[j]=data[i]; ++j; newLength++; delete[] data;//内存管理 data=tmp;//数据内容更新 delete[] hashtable; currentLength=newLength;//更新数组长度 return (oldLength-currentLength); ; 总结： 对于需要反复回溯已遍历元素中某个元素出现与否的，哈希表是一个很好的解决方式，可以减少O(n)O(n)O(n)的算法复杂度。注意哈希表的重点：哈希函数和冲突解决。 例题二：二叉树 给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。请完善下列算法，实现将上述两个二叉树合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。注意：合并后的二叉树中结点允许直接使用这两个二叉树上的结点。给出二叉树的定义： class binaryTree private: struct node//二叉树的节点类 int value; node* left; node* right; node(int val)//构造函数 value=val; left=NULL; right=NULL; ; node* root;//二叉树的根节点 public: node* mergeTrees(node* t1, node* t2)//合并二树 //add your code here ; 想法是：合并二树可以看成三个过程：合并根节点、递归调用合并左右子树。因此，合并二树的操作并不难，只需要注意递归跳出的条件：其中一棵树为空树即可。为了完成代码的检查，我们还需要复习一遍二叉树的构建和层次遍历的知识点。以下代码包含了测试代码，可以直接运行。 #includeiostream#includequeueusing namespace std;class binaryTree private: struct node//二叉树的节点类 int value; node* left; node* right; node(int val)//构造函数 value=val; left=NULL; right=NULL; ; node* root;//二叉树的根节点 public: binaryTree()//基于层次遍历的构造函数 int val; int lval; int rval; coutinput the root:; cinval; coutendl; root=new node(val); queuenode* que1; que1.push(root); while(!que1.empty()) node* tmp=que1.front(); que1.pop(); coutinput the two children of the given node tmp-value:; cinlvalrval; coutendl; if(lval) tmp-left=new node(lval); que1.push(tmp-left); if(rval) tmp-right=new node(rval); que1.push(tmp-right); coutbinarytree has been built!endl; binaryTree(node* r)//给定根节点的构造函数 root=r; void display()//层次遍历 queuenode que1; que1.push(*root); while(!que1.empty()) node tmp=que1.front(); que1.pop(); couttmp.value ; if(tmp.left) que1.push(*(tmp.left)); if(tmp.right) que1.push(*(tmp.right)); coutdisplay completed!endl; node* findRoot()//返回二叉树根节点的位置 return root; node* mergeTrees(node* t1, node* t2)//合并二树 if(!t1) return t2;//递归跳出条件，即其中一棵树是空树 if(!t2) return t1; node* t3=new node(t1-value+t2-value); t3-left=mergeTrees(t1-left,t2-left);//假定该函数能够完成合并二树的操作，只需要对左右子树递归调用 t3-right=mergeTrees(t1-right,t2-right); return t3; ;int main() binaryTree tree1; tree1.display(); binaryTree tree2; tree2.display();//构建两棵树并展示之 binaryTree tree3(tree1.mergeTrees(tree1.findRoot(),tree2.findRoot()));//合并子树 tree3.display(); return 0; 例题三：拓扑排序 题面： 学生需要修读完所有的课程才能毕业，这些课程之间有先导关系（比如要修读数据结构，必须先修读程序设计思想方法）。假设任意一门课程可以在任何一个学期给满足条件的学生选修，且学生每个学期可以选修的课程数不限。先给出一些课程与课程之间的关系，求能够修完所有课程的最少学期数。 输入格式： 第1行：n m //正整数n ，代表课程的数量。非负整数m代表要给出几个先导关系。第2行到第1+m行: a b //每行两个整数：代表要选修编号为a的课程，必须先修读编号为b的课程。 输出格式： 一个整数，即修完所有课程的最少学期数。 思路： 本题可以参考拓扑排序的方式，即：选取入度为零的点，将其移除，然后更新有向图；再移除入度为零的点，如此循环。实现的代码如下，主函数也已经给出，且能够编译通过。 #includeiostream#includequeueusing namespace std;class adjListGraph private: struct edgeNode int end; edgeNode* next; edgeNode(int e,edgeNode* n=NULL) end=e; next=n; ; struct verNode int ver; edgeNode* head; verNode(int val=0) ver=val; head=NULL; ; verNode* verList; int Vers; int* inDegree;//入度统计数组 public: adjListGraph(int vSize)//构造函数 Vers=vSize; verList=new verNode[Vers+1]; inDegree=new int[Vers+1]; for(int i=1;i=Vers;++i) verList[i].ver=i; inDegree[i]=0; void insert(int end,int in) verList[in].head=new edgeNode(end,verList[in].head); inDegree[end]++;//入度增加 int topSort() int counter=0; int remain=Vers;//剩余未被删除的元素个数，用于判断循环结束 int current;//当前将要出队的元素 queueverNode que1; while(remain!=0) for(int i=1;i=Vers;++i) if(inDegree[i]==0) que1.push(verList[i]);//入度为零的点入队 //end for while(!que1.empty()) current=que1.front().ver; que1.pop(); edgeNode*p=verList[current].head; while(p) inDegree[p-end]--;//该出队元素所指向的元素入度自减 p=p-next; remain--; inDegree[current]=-1;//已修完的课在下一次循环不需要被读取 counter++;//完成后计数器增加 return counter; ;int main() int n,m;//课程数量、先导关系 cinnm; adjListGraph graph(n); for(int i=1;i=m;++i) int a,b; cinab; graph.insert(a,b); coutgraph.topSort()endl; return 0; 上述程序中指定队列的原因是，为了区分出每一学期修了多少门课。每一个学期进行一次统一的入队操作，而后出队直至队空为止。","tags":["数据结构"],"categories":["程序设计","算法"]},{"title":"DES加密算法","path":"/posts/3/","content":"DES加密算法是目前使用最广泛的对称加密算法。它体现了对称加密算法中最经典的Feistel结构。尽管DES加密算法注定要为新的加密标准让出位置，但依旧是我们深入理解对称加密的最好的例子。 Feistel结构设计 流密码与分组密码 在最开始，我们有必要了解一下流密码和分组密码。对于明文mmm，我们有两种加密方式，一种是逐位加密，我们称这种加密方式为流密码；另一种方式是按照一定的长度作为一组一同加密，这样的加密方式称为分组密码。流密码的典型例子是凯撒密码，它就是对明文逐位加密的。相较于流密码，我们实际应用中更偏向于使用分组密码，因为流密码有一个缺陷：如果密钥长度不足，那么字符的统计规律就难以被隐藏，很容易受到基于统计的攻击。分组密码在一定程度上会更多地抹去统计信息，因此也就显得更安全。我们主要讨论分组密码。 Feistel密码结构的设计动机 我们不妨假设分组密码作用在长度为nnn的明文分组上，相应地，我们得到相同长度的密文。我们假设明文信息流是二进制流，那么长度为nnn的分组至多有2n2^n2n中情况。考虑到我们需要从密文复原到明文，因此，我们选择的分组替代方式应该是单射的。我们称这样的变换为可逆变换，也叫非奇异变换。上述例子中，非奇异变换一共有2n!2^n!2n!种 （注：对于第一个分组，我们可以从2n2^n2n中选取一个映射；对于第二个，有2n−12^n-12n−1种；以此类推）。这种加密方式下，映射表格就是密钥。这样看来，我们具有很大的密钥空间，任意一种分组情况选取的映射是任意的。我们称这种加解密映射为任意可逆变换。Feistel称这种密码为理想分组密码，因为它允许生成最大数量的加密映射来映射明文分组。 然而，这种方法是难以应用的。如果我们分组的nnn的值不够大（例如4），那它就和流密码没什么区别，非常容易基于统计规律被攻破；那nnn很大的情况呢？统计规律固然被隐藏了，但是我们提过一句话：映射表格就是我们的密钥。对于分组长度为nnn的任意可逆变换，其每种映射需要nnn位表示（即分组长度），并且我们有2n2^n2n中不同分组情况，因此，密钥长度可以表示为 L(n)=n⋅2n.L(n)=n\\cdot 2^n. L(n)=n⋅2n. 指数级的增长是十分恐怖的。今天的密钥长度一般不少于64位，如果我们令上式中的n=64n=64n=64，其结果是102110^{21}1021位！这个长度是不可接受的。因此，Feistel指出，我们只需要一种对任意可逆变换的近似。一般我们认为密钥空间是上面所提到的2n!2^n!2n!中的一个子集。于是，我们依靠什么标准来选取这个密钥空间使得其在降低密钥空间大小的情况下依然能保持足够的安全呢？ Feistel的设想 Feistel提出了一种基于乘积密码的概念来逼近任意可逆变换的方式。乘积密码是说，利用不同的两套或多套密码来加密，得到的结果比其中任意一种的加密效果都要强。特别的，Feistel建议使用替代和置换的反复使用。替代是指明文中的某一元素或某一组被唯一地替换成为密文中的某一元素或某一组；置换是改变明文元素顺序，但明文元素本身并不发生改变。这样的目的是产生混淆和扩散，这是香农提出的概念。其大致原理是，使得密文中的某一字符尽可能多地受到来自不同明文字符的影响，这样做可以有效抵御基于统计的密码分析。当然，最好的情况是所有统计规律都独立于密钥的选取，但这就是我们前面说的任意可逆变换，是不能够实际应用的。排除这种可能，由于密文的生成是明文和密钥的函数，因此，密文的统计规律不可避免出现密钥的信息。因此，大量使用替代和置换可以使这种关系变得复杂，挫败密码分析，这就是我们要的结果。 Feistel结构的基本特征 分组长度：不言而喻的，分组长度越大，密码的安全性就越高。正如前面分析的那样，这种安全性来源于混淆和扩散。一般的分组长度是64-bit，高级加密标准下是128-bit。 密钥长度：密钥越长安全性也显而易见的越高。但是这种安全性建立在牺牲了加解密速度之上。现代密码学中我们认为64-bit的密钥还不够，一般选取128-bit。 迭代轮数：迭代轮数是降低统计特征的最好方式。一般的推荐迭代轮数是16。 子密钥产生算法：我们在前面说过，我们要使用的是乘积密码的原理，因此，如何生成每一步的密钥是关键的问题。产生密钥的算法越复杂，安全性就越高。 轮函数FFF：轮函数是明文和密钥的函数。同样的，轮函数越复杂，密码安全性越高。 快速加解密：对称密码的优势之一就是速度快。作为对称加密算法的Feistel结构，也应当保持这样的优势。 简化分析难度：尽管我们喜欢把算法设计得尽可能使密码分析变得困难，然而将算法设计得易于分析也有它的好处。如果说算法被描述得简单一些，我们就更容易分析出其脆弱性，进而设计更可靠的加密算法。不过，我们后续要介绍的DES并没有简单的分析方式。 Feistel加密算法 本节介绍Feistel加密算法，其大致原理可以用下面的图来直观表示。当然我们也会对整个流程做出解释。 Feistel加密算法 不妨假设我们的明文输入是2w2w2w位的。我们先对其分组，分成两部分，每一个部分是www位长的，并且将它们分别记作LE0LE_0LE0​和RE0RE_0RE0​。我们对这个明文进行第一次迭代。我们如何获取LE1LE_1LE1​呢？很简单，我们直接将输入数据的右半部分拷贝过来即可，即 \\begin{equation} LE_1=RE_0. \\end{equation} 比较复杂的是RE1RE_1RE1​的获得。 我们先选取明文的右半部分RE0RE_0RE0​，对其作用轮函数FFF，密钥选择第一把子密钥，即这部分的运算结果是 F(RE0,K1).F(RE_0,K_1). F(RE0​,K1​). 我们将上述得到的式子和LE0LE_0LE0​作异或运算，于是得到我们需要的RE1RE_1RE1​，这个过程用数学表达式表示就是 \\begin{equation} RE_1=LE_0\\oplus F(RE_0,K_1). \\end{equation} 这就是第一轮迭代的结果。我们将这个迭代再重复15次，即一共迭代16次。上面式子(1)(2)用一般地表示方法即为 \\begin{equation} LE_i=RE_{i-1}, \\end{equation} \\begin{equation} RE_i=LE_{i-1}\\oplus F(RE_{i-1},K_{i}). \\end{equation} 当我们得到 LE16LE_{16}LE16​ 和 RE16RE_{16}RE16​ 后，我们对这两部分作最后一次交换，得到 LE17=RE16,LE_{17}=RE_{16}, LE17​=RE16​, RE17=LE16,RE_{17}=LE_{16}, RE17​=LE16​, 于是，上述两段拼接起来就是我们产生的密文。 这就是Feistel结构的加密过程。 Feistel解密算法 既然其加密算法看上去这么复杂，其解密算法会不会也很复杂呢？答案是并不是。其解密算法和加密算法完全一致，除了使用密钥的顺序和加密过程相反。这样究竟能不能复原出明文，这是我们关心的问题，下面我们给出证明。 我们要知道的是，LEiLE_iLEi​和REiRE_iREi​在我们知道密钥KiK_iKi​的情况下能不能反解出前一步的密文。我们由式(4)可以知道 LEi−1=REi⊕F(REi−1,Ki),LE_{i-1}=RE_i\\oplus F(RE_{i-1},K_i), LEi−1​=REi​⊕F(REi−1​,Ki​), 又由于REi−1=LEiRE_{i-1}=LE_iREi−1​=LEi​，有 LEi−1=REi⊕F(LEi,Ki).LE_{i-1}=RE_i\\oplus F(LE_i,K_i). LEi−1​=REi​⊕F(LEi​,Ki​). 又显然有 REi−1=LEi,RE_{i-1}=LE_i, REi−1​=LEi​, 也就是说，我们获得了密文后，便可以一层层代入解密。至于在加密过程中为什么要增加一步互换位置，是因为互换以后我们得到的密文中的右半部分 RD0=RE17=LE16,RD_0=RE_{17}=LE_{16}, RD0​=RE17​=LE16​, 这样，我们在解密过程中可以保持对右半部分使用轮函数，保证了加密解密算法的一致。 值得注意的是，上述论证过程中我们并没有假设轮函数具有什么性质，因为事实上，轮函数是可以任意选取的，这不影响我们的解密过程。我们后面要讲述的DES，实际上是Feistel结构的一个具体实现。 DES加密算法 DES加密算法以64位为分组，密钥长度为56位 （实际上，使用的密钥为64位，但是其中8位是校验位，不参与实际运算，因此说是56位）。加密的粗糙流程可见下图。 DES加密流程 我们获取到明文输入后，首先对其进行初始置换(IPIPIP)，然后经过16轮迭代，最后经过左右互换（这点在Feistel结构中提到过），然后通过逆初始置换(IP−1IP^{-1}IP−1)，得到密文输出。初始置换和逆初始置换是一对互逆运算。笔者认为其存在的意义仅仅是增加解密复杂度。每一轮加密的密钥来源于64位初始密钥生成的子密钥。以下我们解释一下DES的详细加密过程。 初始置换 初始置换和逆初始置换只在最开始和结束使用，其原理是地址置换，即将对应位置所指的地址的数据置换到该位上。下面给出了具体的初始置换和逆初始置换表。这里不多赘述。 初始置换 逆初始置换 轮函数的细节 我们先给出轮函数的示意图，然后再解释。 轮函数的细节 如同我们在Feistel结构中提到的，我们对64位明文信息分组称为左右两部分。由图上可知，轮函数外的步骤和Feistel结构完全一致，我们不多赘述。关键来看一下轮函数中的最重要的四步：E扩展置换，子密钥运算，S盒压缩和P置换。 E扩展置换 由于参加运算的子密钥是48位的，然而分组后我们的明文信息只有32位，因此，需要对明文信息扩展称为48位。E扩展是有对应表格的，它接受32位的输入，产生48位的输出。具体的扩展方式可以见下面的表格和例子。这样的扩展会产生16个重复的位。 Ebox 子密钥运算 将扩展置换结果与子密钥进行异或运算。 S盒压缩 上述的运算结果是48位的，然而，轮函数迭代后的位数是不能够增多的。因此，我们需要对48位的数据压缩，将之长度还原到32位。S盒压缩就是在完成这一步。**S盒压缩接受48位的输入，产生32位的输出。**其原理如下图。 S盒压缩过程 S盒首先将输入分成6位一组，共计8组。我们不妨假设输入是011001。首先我们获取输入的首尾两位，将其作为行号；剩余的四位作为列号。在上面的例子中，行号是1（01）；列号是12（1100）。我们查询S盒置换表，知道这一位数字是9，即1001。于是，1001就是我们的输出。对于其他7组也是如此，最后一共输出8组4位，共32位的结果。值得注意的是，S盒不止一个。其设计标准是不公开的，但S盒是公开的。 P置换 也是一种简单的置换，具有置换对照表。 子密钥的生成 我们输入的是64位的密钥。于是我们通过PC-1置换，将密钥的校验位去除，同时打乱密钥的顺序，得到56位的密钥。对这个56位密钥我们再次进行分组，分为左右两半部分各28位长度的密钥。我们把这个密钥称为C0D0C_0D_0C0​D0​。我们对其两部分分别进行左移，左移位数查表可见。对于每一次的左移结果，我们通过PC-2置换得到该次加密的子密钥。重复上述操作，我们可以得到所有加密过程需要的子密钥。 子密钥生成使用的PC-1、PC-2置换 DES密码的强度 对于P置换和S盒压缩是有要求的，就是要尽可能增加其中某一位对其他所有位变化的敏感度，也就是说，增加算法的扩散程度，来弥补分组算法本身难以逃脱统计攻击的特点。因此，不论是置换表格的设计，又或是子密钥的生成，都要严格遵循一个效应，我们称之为雪崩效应。雪崩效应说的是，明文或密钥的微小改变将对密文产生很大的影响，换句话说，明文和密钥的任何一位的改变会导致密文很多位的改变。这样，分析者搜索密钥的难度大大上升，加密算法也更加健壮。 但，DES密码并不是牢不可破的。其安全性一直备受质疑。曾在1998年，有一台专门针对DES加密算法的计算机成功破译了DES加密算法。但实际上，这种破译往往需要我们知道待破译的目标语言特点，例如语言特征，文件格式等等。因此，在不知道这些信息的情况下，破译DES依然是有难度的。不论如何，我们如今也有许多DES的替代加密方案例如AES和3DES。对这些方案，我们后续也会加以讨论。 不论如何，Feistel结构和DES加密算法仍旧是对称加密算法中的经典，理解它们对我们后续的深入学习是有百利而无一害的。","tags":["密码学"],"categories":["安全","密码学"]},{"title":"KMP算法","path":"/posts/2/","content":"问题 给定一个字符串AAA，要求从字符串AAA中查找另一个字符串BBB是否出现。如果出现，返回查找的字符串BBB在AAA中的位置，否则返回-1。 最简单的解决方法——枚举法 枚举法当然可以解决这个问题：我们可以在从AAA字符串中取第一位，然后逐位往后与BBB串比较。如果匹配则返回答案；若不匹配，则从AAA字符串的第二位开始，重复上述操作，直到找到字符串位置或者字符串AAA被遍历完毕。 我们来分析一下这个的算法复杂度。我们假设字符串AAA和BBB的长度分别为mmm和nnn，那么这个算法的最差情况需要比较m×nm\\times nm×n次，即这个算法是O(m×n)O(m\\times n)O(m×n)的。 KMP算法 KMP算法是一个很好的解决算法，它可以 最多只扫描一次字符串AAA 就能完成任务，即它的算法复杂度是O(n)O(n)O(n)的。之所以被叫作KMP算法，是因为它是由Knuth、Morris、Pratt三个人提出的。下面来介绍一下该算法的思想。 简单的直观模拟 为了说明KMP的大致过程，我们先给出一个例子。 一个例子 我们参考上例，并且称大数组为chchch，目标数组为targettargettarget。我们从第一位开始逐个比较chchch和targettargettarget中的每一位，直到不匹配为止，如图(a)所示。我们发现，ch[6]!=target[6]ch[6]!=target[6]ch[6]!=target[6]。但是在i⩽5i\\leqslant 5i⩽5都有ch[i]=target[i]ch[i]=target[i]ch[i]=target[i]。我们此时不将targettargettarget往后移动一位，选择往后移动两位，因为**这个时候ch[2]ch[2]ch[2]到ch[6]ch[6]ch[6]仍然和目标字符串是匹配的。**我们可以证明，这个位置是除了初始位置外第二个可能的匹配发生的位置。因为如果在此之前还存在一个匹配的字符串，那么我们要么已经找到了它，要么重定位会定位到它，而不是 ch[2]ch[2]ch[2] 。如果你能理解这点，这就是KMP算法的基本原理。 失效函数 失效函数原理 那么随之而来的问题是：我们如何确定应该向后移动几位呢？ 以及，如果每次向后移动都可以看做字符串targettargettarget正在比较元素的后退，（正如上例中本在比较target[6]target[6]target[6]和ch[6]ch[6]ch[6]，向后移动后相当于比较target[4]target[4]target[4]和ch[6]ch[6]ch[6]） 那么到底后退几位呢？ 如果我们把字符串中正在比较的元素位置记作jjj，后退后正在比较j′j^\\primej′，那么我们可以知道它们满足：target[0]target[0]target[0]到target[j′]target[j^\\prime]target[j′]之间的字符串和target[j−j′]target[j-j^\\prime]target[j−j′]到target[j]target[j]target[j]之间的字符串完全相同。这里需要读者仔细理解一下，我们实际上取的j′j^\\primej′是使得targettargettarget中前j′+1j^\\prime+1j′+1和后j′+1j^\\prime+1j′+1个字符完全相同，也就是我们在前一节说的直观模拟的结果。 我们把jjj和j′j^\\primej′的对应关系称为失效函数，即 j′=P[j].j^\\prime =P[j]. j′=P[j]. 有了这个对应关系，我们就可以轻松决定，当字符串正在比较位置i,ji,ji,j相同，即ch[i]=target[j]ch[i]=target[j]ch[i]=target[j]时，但位置i+1,j+1i+1,j+1i+1,j+1不同，即ch[i+1]≠target[j+1]ch[i+1] eq target[j+1]ch[i+1]=target[j+1]时，jjj需要更新成什么了。 失效函数的算法 我们从上述论断中可以知道，失效函数的产生只和目标数组targettargettarget有关，因此我们可以对目标数组预处理，得到其失效函数。那么，失效函数的算法是什么呢？ 首先，我们知道对于target[0]target[0]target[0]，是没有满足失效函数定义的下标j′j^\\primej′的，那么，我们定义这种条件下，其失效函数值为-1。然后我们用递推的方式求出其他元素的失效函数。我们现在要求下标为jjj的元素的失效函数，那么我们考察j−1j-1j−1位置上的元素，其失效函数的值为j0j_0j0​，那么也就是说，target[0]target[0]target[0]到target[j0]target[j_0]target[j0​]之间的字符串和target[j−1−j0]target[j-1-j_0]target[j−1−j0​]到target[j−1]target[j-1]target[j−1]之间的字符串完全相同，那么我们只要比较target[j0+1]target[j_0+1]target[j0​+1]和target[j]target[j]target[j]是否相同，即比较target[P[j−1]+1]target[P[j-1]+1]target[P[j−1]+1]和target[j]target[j]target[j]是否相同。如果也相同，那么P[j−1]+1=P[j]P[j-1]+1=P[j]P[j−1]+1=P[j]；否则，我们可以令P[j0]P[j_0]P[j0​]是新的j0j_0j0​，继续反复上次的比较，直到找到target[0]target[0]target[0]并且target[0]target[0]target[0]和target[j]target[j]target[j]也不相等，那么其失效函数的值为-1 。 失效函数的实现 这节给出失效函数failurefunc()的实现。 int* failurefunc(const seqString target)const int* p=new int[target.len];//申请一个数组，存放失效函数 int j; p[0]=-1;//首元素的失效函数值为-1 for(int i=1;itarget.len;++i) j=i-1;//往前退一位 while(j=0target.data[p[j]+1]!=target.data[i]) j=p[j];//如果最长相同子序列不存在，那么缩短相同子序列长度 if(j0) p[i]=-1;//直到找完都没有找到，则失效函数为-1 else p[i]=p[j]+1;//找到了，更新失效函数的值 //end for return p;//end function 查找函数 有了上面的失效函数，我们可以完成KMP算法中的查找部分了。 查找函数的原理 查找函数使用两个指针iii和jjj，分别指向字符串chchch和targettargettarget中正在比较的元素。从两字符串头开始，对i,ji,ji,j一同自增，直到发现ch[i]!=target[j]ch[i]!=target[j]ch[i]!=target[j]就停止；此时，利用失效函数，对jjj的值进行更新，更新为其前一个元素失效函数的值后的元素，即P[j−1]+1P[j-1]+1P[j−1]+1，然后重新比较iii和jjj，重复上述步骤，直到j=0j=0j=0时还是无法匹配，则固定jjj，对iii自增，直到匹配为止。搜索过程退出的条件是：找到了targettargettarget的位置，即j=target.len−1j=target.len-1j=target.len−1；或者未找到，即i=ch.len−1i=ch.len-1i=ch.len−1。 查找函数的实现 本节实现查找函数。 int find(const seqString ch, const seqString target) int* p=NULL;//存放失效函数 p=failurefunc(target);//获取失效函数 int i=j=0;//定位指针 while(ich.lenjtarget.len) if(ch.data[i]==target.data[j]) i++;j++;//相等则自增 else if(j==0) i++;//不相等但是j已经为零时，i自增 else j=p[j-1]+1;//否则更新j的值 //end while delete p;//释放内存 if(j==target.len) //比较完最后一个字符后，j又自增了一次，所以应该是最后一个元素的下标+1 return i-j;//如果找到了以后才退出，那么返回位置 else return -1;//否则就是没找到，返回未找到 后记 KMP算法的时间复杂度是O(n)O(n)O(n)的，因为我们即便可能需要扫描目标字符串许多遍，但主字符串我们只需要扫描一遍，也就是说不会超过nnn次。KMP算法为什么能节省时间，本质上使我们利用了扫描匹配过程中匹配失败的信息。对于匹配失败的节点，我们利用两个指针直接跳过了许多次扫描，因而节省了时间。可以说，KMP算法相比于枚举法有着更高的信息利用率。","tags":["数据结构","算法"],"categories":["程序设计","算法"]},{"title":"RSA加密算法","path":"/posts/1/","content":"加密算法 谈到加密算法，我们不得不谈一下密码学中加密算法的两个分支：对称加密和非对称加密。 对称加密算法（以单表替代密码为例） 我们假设Felix要向你们之间的某位读者发送一段信息mmm，为方便起见，我们假设这段信息是THANKYOUFORFOLLOWINGME。现在，为了使这段信息不被外人所知，需要对其加密。我们假设加密方式为：所有用后一位字母替代，那么上述的这段信息就被加密为：“UIBOLZPVGPSGPMMPXJOHNF”，这是不可读的。当读者接收到这段信息时，只需要将加密后的信息往前倒退一位，便可以得到原始信息。我们把原始信息称为明文，加密后的信息称为密文，加密方式（在上例中体现为字母的替代）称为加密算法，解密方式（在上例中体现为字母的替代）称为解密算法，加密时移动的位数1称为加密密钥，解密时移动的位数1称为解密密钥。 上面这种加密方式一般被称为单表替代密码，上述的例子又是其中十分特殊的一种，称为凯撒密码。我们观察可以知道，加密密钥和解密密钥是相同的，我们把具有这种性质的加密算法称为对称加密算法。 对称加密算法是有好处的：其计算量小，加密简单，用于加密和解密的密钥相同，算法只需要选取可逆映射即可。但对称加密也存在一些问题：双方在通信前需要互相商定密钥，并且在通信过程中，任何一方的密钥泄露都将使得所有通信被破解；其次，任何两者之间的通信都需要选取不同的密钥，这在通信网复杂的情况下，每个通信节点都需要储存数量庞大的密钥，给用户带来负担。 当然，密钥泄露的问题不是不可解决的。我们可以在每一次通信都使用不同的密钥，这样，密文在理论上是牢不可破的。但是这又会带来问题，我们如何获得这么庞大数量的密钥呢？我们又如何储存呢？密钥的分发在这种情况下变成了棘手的问题。所以，一次一密的加密方式在实际应用中是不广泛的。 非对称加密 随即而来进入我们脑海的一种加密方式就是非对称加密，即加密密钥和解密密钥不相同的加密方式。我们一般称前者为公钥，后者为私钥，因为前者是公开给所有人的，后者是密文接收方自己保存的。我们知道，由于加密和解密是逆运算，我们是有可能通过暴力破解求出加密方式的逆运算的。所以，为了保证安全性，非对称加密的算法一般都十分复杂，运算量相比于对称加密算法繁琐得多，因此，非对称加密牺牲了加密效率，换来了更高的安全性。下面我们来讨论一下非对称加密中的典型加密方式，即RSA加密。 RSA加密算法 基于的数学运算原理——模运算 首先我们来思考一个问题，有什么方式使得攻击者知道加密方式的情况下很难求算出其逆运算？有一种运算符合类似的性质：其正向运算十分简单，但逆运算极其复杂，它是模运算（Mod）。模运算就是我们一般说的求余。其正向运算是很简单的，例如 33 mod 7=6,3^3\\ \\textrm{mod}\\ 7=6, 33 mod 7=6, 完成这个运算只需要一个简单的除法即可，但是设想，如果给出的形式是方程，即 3x mod 7=6,3^x\\ \\textrm{mod}\\ 7=6, 3x mod 7=6, 求解满足上述方程的x的值，其运算是比较复杂的，因为我们不知道其商的值，也就不能快速利用乘法求算xxx，一般我们会使用枚举法求算其解。但是如果方程是 3x mod 7156464845153468615315646=6,3^x\\ \\textrm{mod}\\ 7156464845153468615315646=6, 3x mod 7156464845153468615315646=6, 这时候，枚举法也变得十分困难了，这个方程已经是计算上不可解的了。因此，模运算也被称为单向运算。RSA就是利用了模运算的这点性质。 加密算法和解密算法确定 知道了我们要使用模运算作为加密和解密算法，那么我们不妨假设明文信息是mmm（message），密文信息是ccc（cipher），公钥为eee，私钥为ddd，于是我们可以得到 {me mod N=c,cd mod N=m.\\begin{cases} m^e\\ \\textrm{mod}\\ N=c,\\\\ c^d\\ \\textrm{mod}\\ N=m. \\end{cases} {me mod N=c,cd mod N=m.​ 消去密文ccc，上式可化为 (me mod N)d mod N=m,(m^e\\ \\textrm{mod}\\ N)^d\\ \\textrm{mod}\\ N=m, (me mod N)d mod N=m, 可以证明上式等价于 med mod N=m.m^{ed}\\ \\textrm{mod}\\ N=m. med mod N=m. 这个结论先放在这里，我们后续会使用到它。 欧拉函数和欧拉定理 为了充分理解RSA密码的数学原理，我们需要先提到欧拉函数和欧拉定理。 欧拉函数 首先介绍一下欧拉函数：假设给定一个正整数nnn，欧拉函数φ(n)\\varphi(n)φ(n)的值是不超过nnn的与其互质的正整数的数目，例如不超过6的与6互质的正整数有1和5，那么我们就说，φ(6)=2\\varphi(6)=2φ(6)=2。一般求解欧拉函数的值时，我们经常采用素因数分解的方式，让我们来看一个例子：求解φ(100)\\varphi(100)φ(100)的值。我们对其质因数分解，得到 100=22⋅52。100=2^2\\cdot 5^2。 100=22⋅52。 那么其与其互质的整数数量为 φ(100)=100×(1−12)×(1−15)=40.\\varphi(100)=100\\times(1-\\dfrac{1}{2})\\times(1-\\dfrac{1}{5})=40. φ(100)=100×(1−21​)×(1−51​)=40. 对于任意正整数xxx，假设其各个质因数为pip_ipi​，那么其欧拉函数的值为 φ(x)=x∏i=1n(1−1pi).\\varphi(x)=x\\prod^n_{i=1}(1-\\dfrac{1}{p_i}). φ(x)=xi=1∏n​(1−pi​1​). 显然，这样计算一个正整数的欧拉函数是很复杂的。但如果上式中的xxx是质数呢？问题就变得非常简单，因为这时Pi={x}P_i=\\{x\\}Pi​={x}。于是我们可以知道，质数ppp的欧拉函数为 φ(p)=p−1.\\varphi(p)=p-1. φ(p)=p−1. 同样的，如果对于两个互质的正整数p,qp,qp,q，其乘积的欧拉函数就等于欧拉函数的乘积，即 φ(p×q)=φ(p)×φ(q).\\varphi(p\\times q)=\\varphi(p)\\times \\varphi(q). φ(p×q)=φ(p)×φ(q). 这为我们求解欧拉函数提供了一个很好的解决方式。 欧拉定理 欧拉定理是数论中的重要定理，我们这里只做介绍，不作证明。欧拉定理说的是，对于互质的两正整数mmm和nnn，满足以下关系恒成立： mφ(n)≡1 (mod n),m^{\\varphi(n)}\\equiv1\\ (\\textrm{mod}\\ n), mφ(n)≡1 (mod n), 我们对上式两边同时取kkk次幂，得到 mkφ(n)≡1 (mod n),m^{k\\varphi(n)}\\equiv1\\ (\\textrm{mod}\\ n), mkφ(n)≡1 (mod n), 两边同时乘上mmm，有 mkφ(n)+1≡m (mod n),m^{k\\varphi(n)+1}\\equiv m\\ (\\textrm{mod}\\ n), mkφ(n)+1≡m (mod n), 改写得到 mkφ(n)+1 mod n=m.m^{k\\varphi(n)+1}\\ \\textrm{mod}\\ n= m. mkφ(n)+1 mod n=m. 这是我们需要的欧拉定理的形式。 密钥的生成 读者是否还记得我们在确定算法的时候找到了公钥和私钥的关系式？即 med mod N=m.m^{ed}\\ \\textrm{mod}\\ N=m. med mod N=m. 与我们得到的欧拉定理的形式 mkφ(n)+1 mod n=m.m^{k\\varphi(n)+1}\\ \\textrm{mod}\\ n=m. mkφ(n)+1 mod n=m. 相比，我们发现，这时我们只需要使得 ed=kφ(N)+1，ed=k\\varphi(N)+1， ed=kφ(N)+1， 即对于任何一个公钥eee，我们私钥ddd的生成方式为计算ddd使得 ed mod φ(N)=1.ed\\ \\textrm{mod}\\ \\varphi(N)=1. ed mod φ(N)=1. 这时我们可以利用到一条数学定理：如果两正整数互质（这里表现为ddd与φ(N)\\varphi(N)φ(N)互质），那么一定存在ddd满足上述关系，即ed−1ed-1ed−1被φ(N)\\varphi(N)φ(N)整除，我们称这样的ddd为模反元素。 所以，我们只要保证公钥eee和求得的φ(N)\\varphi(N)φ(N)互质，那么私钥ddd的存在性是不言而喻的。那么现在问题的关键就是：如何确定φ(N)\\varphi(N)φ(N)和eee的值。 我们任意选取足够大的两个质数ppp和qqq，这是我们产生φ(N)\\varphi(N)φ(N)的来源。我们令N=p⋅qN=p\\cdot qN=p⋅q，这样的NNN通常是非常大的，理论上计算φ(N)\\varphi(N)φ(N)需要对其进行质因数分解，然而对不知道ppp和qqq的人来说，这几乎是不可能的事情，因为NNN的质因数分解被证明是计算上不可行的了。但作为密钥的分发方，我们却很容易解出，因为我们选取的是两个质数，利用欧拉函数的性质，我们很容易知道 φ(N)=φ(p⋅q)=φ(p)⋅φ(q)=(p−1)(q−1).\\varphi(N)=\\varphi(p\\cdot q)=\\varphi(p)\\cdot\\varphi(q)=(p-1)(q-1). φ(N)=φ(p⋅q)=φ(p)⋅φ(q)=(p−1)(q−1). 有了这个解，我们只需要任意取一个和φ(N)\\varphi(N)φ(N)互质的数就行了。由此，我们将(e,N)(e,N)(e,N)作为公钥发送出去，待我们计算出ddd后，保留(d,N)(d,N)(d,N)作为私钥即可。销毁ppp和qqq，这样这组公钥私钥几乎是无法被破解的了。 加密流程总结 至此，我们已经知道了加密基于的数学原理和方法，这里我们来一些总结。 步骤 内容 生成 1 选取两个不相等的足够大的质数 ppp和qqq 2 计算它们的乘积N=p×qN=p\\times qN=p×q NNN 3 利用NNN的因数计算其欧拉函数φ(N)=(p−1)×(q−1)\\varphi(N)=(p-1)\\times(q-1)φ(N)=(p−1)×(q−1) φ(N)\\varphi(N)φ(N) 4 选取任一与φ(N)\\varphi(N)φ(N)互质的整数eee 公钥成员eee 5 计算模反元素ddd：ed mod φ(N)=1ed\\ \\textrm{mod}\\ \\varphi(N)=1ed mod φ(N)=1 私钥成员ddd 6 公布公钥(e,N)(e,N)(e,N) 公钥(e,N)(e,N)(e,N) 7 保存私钥(d,N)(d,N)(d,N) 私钥(d,N)(d,N)(d,N) 8 销毁ppp和qqq 无 这就是RSA加密算法的原理和流程。 关于关键的ppp和qqq 我们知道，如果两个数很接近，那么它们的差值一定很小。如果我们选取的ppp和qqq相差不大，那么RSA在这种情况下是很容易被攻破的。我们可以假设pqpqpq并且 p=a+b,q=a−b,p=a+b,\\quad q=a-b, p=a+b,q=a−b, 那么大数NNN就可以被表示为 N=p×q=(a+b)(a−b)=a2−b2.N=p\\times q=(a+b)(a-b)=a^2-b^2. N=p×q=(a+b)(a−b)=a2−b2. 由于bbb很小，所以aaa和N\\sqrt{N}N​的值非常接近，于是我们可以轻易倒推出用于产生密钥的ppp和qqq的值。这种情况下，RSA的安全性很低。但好在幸运的是，应用中不会产生这样的错误，所以RSA依然是很可靠的加密方式。 后记 从对于RSA彻底的分析来看，密码学在本质上是数学的实际应用。笔者在理解RSA密码加密的学习过程中，其实更多的时候都在了解其基于的数学原理，而并非大多数人所认为的加密过程。站在一个高度看RSA密码，其实其可靠性是由于人类对质因数分解掌握的不完全所保证的，因为知道公钥(e,N)(e,N)(e,N)，从理论上是可以破解私钥的，只是实际不可行罢了。当然，我们也不能因此质疑RSA密码的可靠性，因为密码学对密码是否可用的标准一直只有两条：破解密码耗费的资源大于信息本身，或者破解密码需要的时间远大于信息的时效性，而并没有将牢不可破作为其中的标准。 RSA密码在历史上首次是被政府发现的，然后其就一直作为机密被尘封起来。直到1977年，三位麻省理工的数学家独立发掘出这种公钥私钥计算方法，然后才成为了如今广泛使用的RSA加密算法。这个算法也由他们的名字命名：Ron Rivest,Adi Shamir,Leonard Adleman。 公开RSA的三位数学家 回过来看这个优美的表达式 d=kφ(N)+1e,d=\\dfrac{k\\varphi(N)+1}{e}, d=ekφ(N)+1​, 一对看似无关的数字却连接着探索真相的答案，一个看似简单的算法却暗藏着千年未解的数学难题，这或许就是密码最终的魅力。","tags":["密码学"],"categories":["安全","密码学"]},{"title":"友链","path":"/friends/index.html","content":"置顶链接 BeaCox 友情链接 慕雪的寒舍iMaeGoo’s Blog杜老师说星日语SkyReevesUyoAhzMerryJinglexaoxuu一蓑烟雨的博客 欢迎互换友链，请通过本站底部的联系方式与我取得联系。"}]